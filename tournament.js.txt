// tournament.js
// –í—Å—è –ª–æ–≥–∏–∫–∞ —Ç—É—Ä–Ω–∏—Ä–æ–≤ –∏ UI.
// –†–∞–±–æ—Ç–∞–µ—Ç –∏ –¥–ª—è index.html (public), –∏ –¥–ª—è admin.html (admin).

import {
  loadStateFromCloud,
  saveStateToCloud,
  subscribeToState,
  EMPTY_STATE,
} from "./firebase.js";

const isAdminPage = document.body.dataset.page === "admin";

let currentState = structuredClone(EMPTY_STATE);
let isInitialized = false;

// id —Ç—É—Ä–Ω–∏—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π —Å–µ–π—á–∞—Å —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º –≤ –∞–¥–º–∏–Ω–∫–µ
let adminEditingTournamentId = null;

// –§–∏–ª—å—Ç—Ä—ã –∏—Å—Ç–æ—Ä–∏–∏ (–µ—Å–ª–∏ —Ä–µ—à–∏–º —Å–Ω–æ–≤–∞ –≤–∫–ª—é—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ)
let publicHistoryFilter = "all";
let adminHistoryFilter = "all";

// ---------------------
// –£—Ç–∏–ª–∏—Ç—ã
// ---------------------

function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function generateId(prefix) {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

function escapeHtml(str) {
  if (!str) return "";
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function formatDateTime(ts) {
  if (!ts) return "";
  const d = new Date(ts);
  return d.toLocaleString("ru-RU", {
    day: "2-digit",
    month: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
}

function getActiveTournament(state) {
  if (!state) return null;
  const id = state.activeTournamentId;
  if (!id) return null;
  return (state.tournaments || []).find((t) => t.id === id) || null;
}

function getTournamentById(state, id) {
  if (!state || !id) return null;
  return (state.tournaments || []).find((t) => t.id === id) || null;
}

function getEditingTournament(state) {
  return getTournamentById(state, adminEditingTournamentId);
}

function ensureTournamentShape(t) {
  const copy = deepClone(t);
  copy.players = Array.isArray(copy.players) ? copy.players : [];
  copy.groups = Array.isArray(copy.groups) ? copy.groups : [];
  copy.history = Array.isArray(copy.history) ? copy.history : [];
  copy.playoffs = copy.playoffs || {};
  copy.playoffs.mastersBracket = copy.playoffs.mastersBracket || null;
  copy.playoffs.challengeBracket = copy.playoffs.challengeBracket || null;
  copy.status = copy.status || "registration";
  copy.registrationOpen = !!copy.registrationOpen;
  return copy;
}

function normalizeState(state) {
  if (!state || typeof state !== "object") return deepClone(EMPTY_STATE);
  const s = deepClone(state);
  s.tournaments = Array.isArray(s.tournaments) ? s.tournaments : [];
  s.activeTournamentId =
    typeof s.activeTournamentId === "string" ? s.activeTournamentId : null;
  s.tournaments = s.tournaments.map(ensureTournamentShape);
  return s;
}

function updateState(mutator) {
  const next = deepClone(currentState);
  mutator(next);
  saveStateToCloud(next).catch((err) => {
    console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è:", err);
  });
}

function shuffleInPlace(arr) {
  arr.sort(() => Math.random() - 0.5);
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—á—ë—Ç–∞ –º–∞—Ç—á–∞ (–¥–æ –¥–≤—É—Ö –ø–æ–±–µ–¥)
function isValidScore(score1, score2) {
  const a = Number(score1);
  const b = Number(score2);
  if (!Number.isInteger(a) || !Number.isInteger(b)) return false;
  if (a < 0 || b < 0) return false;
  const sum = a + b;
  if (sum < 2 || sum > 3) return false;
  if (a !== 2 && b !== 2) return false;
  if (a === 2 && (b === 0 || b === 1)) return true;
  if (b === 2 && (a === 0 || a === 1)) return true;
  return false;
}

// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –∏ –ø—Ä–æ–∏–≥—Ä–∞–≤—à–µ–≥–æ –ø–æ —Å—á—ë—Ç—É
function getWinnerLoser(score1, score2, player1Id, player2Id) {
  const a = Number(score1);
  const b = Number(score2);
  if (!isValidScore(a, b)) return null;
  if (a > b) {
    return { winnerId: player1Id, loserId: player2Id };
  }
  return { winnerId: player2Id, loserId: player1Id };
}

// –ï—Å—Ç—å –ª–∏ —É–∂–µ —Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏ –≤ –≥—Ä—É–ø–ø–∞—Ö / –ø–ª–µ–π-–æ—Ñ—Ñ
function hasGroupResults(tour) {
  return (tour.groups || []).some((g) =>
    (g.matches || []).some((m) => m.score1 != null || m.score2 != null)
  );
}

function hasPlayoffResults(tour) {
  const po = tour.playoffs || {};
  const checkBracket = (b) =>
    b &&
    Array.isArray(b.rounds) &&
    b.rounds.some((r) =>
      (r.matches || []).some((m) => m.score1 != null || m.score2 != null)
    );
  return checkBracket(po.mastersBracket) || checkBracket(po.challengeBracket);
}

// ---------------------
// –õ–æ–≥–∏–∫–∞ –≥—Ä—É–ø–ø
// ---------------------

// –ê–ª–≥–æ—Ä–∏—Ç–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏–≥—Ä–æ–∫–æ–≤ –ø–æ –≥—Ä—É–ø–ø–∞–º 4‚Äì5 —á–µ–ª–æ–≤–µ–∫
function createGroupsFromPlayers(players) {
  const shuffled = [...players];
  shuffleInPlace(shuffled);

  const total = shuffled.length;
  if (total < 4) {
    return [
      {
        playerIds: shuffled.map((p) => p.id),
      },
    ];
  }

  let groupsCount = Math.round(total / 4);
  if (groupsCount < 1) groupsCount = 1;

  if (total % 4 === 3 && groupsCount > 1) {
    groupsCount -= 1;
  }

  let baseSize = Math.floor(total / groupsCount);
  let remainder = total % groupsCount;

  let sizes = new Array(groupsCount).fill(baseSize);
  for (let i = 0; i < remainder; i++) {
    sizes[i]++;
  }

  for (let i = 0; i < sizes.length; i++) {
    if (sizes[i] === 3) {
      let j = sizes.findIndex((s, idx) => s > 4 && idx !== i);
      if (j !== -1) {
        sizes[i] = 4;
        sizes[j]--;
      }
    }
  }

  const groups = [];
  let index = 0;
  for (let g = 0; g < sizes.length; g++) {
    const size = sizes[g];
    const slice = shuffled.slice(index, index + size);
    index += size;
    groups.push({
      playerIds: slice.map((p) => p.id),
    });
  }

  return groups;
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –º–∞—Ç—á–µ–π "–∫–∞–∂–¥—ã–π —Å –∫–∞–∂–¥—ã–º" –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã
function createRoundRobinMatchesForGroup(tournamentId, groupId, playerIds) {
  const matches = [];
  for (let i = 0; i < playerIds.length; i++) {
    for (let j = i + 1; j < playerIds.length; j++) {
      matches.push({
        id: generateId("gm"),
        tournamentId,
        groupId,
        stage: "groups",
        player1Id: playerIds[i],
        player2Id: playerIds[j],
        score1: null,
        score2: null,
        createdAt: Date.now(),
      });
    }
  }
  return matches;
}

// –ü–µ—Ä–µ—Å—á—ë—Ç standings –¥–ª—è –≥—Ä—É–ø–ø—ã (—É—á–∏—Ç—ã–≤–∞–µ–º –∏ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏, –µ—Å–ª–∏ –µ—Å—Ç—å)
function recomputeGroupStandings(group, tournament) {
  const playersMap = new Map(tournament.players.map((p) => [p.id, p]));
  const stats = new Map();

  for (const pid of group.playerIds) {
    stats.set(pid, {
      playerId: pid,
      wins: 0,
      losses: 0,
      setsFor: 0,
      setsAgainst: 0,
      points: 0,
    });
  }

  for (const match of group.matches || []) {
    if (match.score1 == null || match.score2 == null) continue;
    const a = Number(match.score1);
    const b = Number(match.score2);
    if (!isValidScore(a, b)) continue;

    const stat1 = stats.get(match.player1Id);
    const stat2 = stats.get(match.player2Id);
    if (!stat1 || !stat2) continue;

    // —Å–µ—Ç—ã
    stat1.setsFor += a;
    stat1.setsAgainst += b;
    stat2.setsFor += b;
    stat2.setsAgainst += a;

    // –ø–æ–±–µ–¥—ã / –ø–æ—Ä–∞–∂–µ–Ω–∏—è + —Å–∏—Å—Ç–µ–º–∞ –æ—á–∫–æ–≤:
    // 2:0 ‚Üí 3 –æ—á–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—é
    // 2:1 ‚Üí 2 –æ—á–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—é –∏ 1 –æ—á–∫–æ –ø—Ä–æ–∏–≥—Ä–∞–≤—à–µ–º—É
    if (a > b) {
      stat1.wins++;
      stat2.losses++;
      if (a === 2 && b === 0) {
        stat1.points += 3;
      } else {
        stat1.points += 2;
        stat2.points += 1;
      }
    } else {
      stat2.wins++;
      stat1.losses++;
      if (b === 2 && a === 0) {
        stat2.points += 3;
      } else {
        stat2.points += 2;
        stat1.points += 1;
      }
    }
  }

  const standings = Array.from(stats.values());

  standings.sort((a, b) => {
    // 1) –æ—á–∫–∏
    if (b.points !== a.points) return b.points - a.points;

    // 2) —Ä–∞–∑–Ω–∏—Ü–∞ —Å–µ—Ç–æ–≤
    const diffA = a.setsFor - a.setsAgainst;
    const diffB = b.setsFor - b.setsAgainst;
    if (diffB !== diffA) return diffB - diffA;

    // 3) –Ω–∞–±—Ä–∞–Ω–Ω—ã–µ —Å–µ—Ç—ã
    if (b.setsFor !== a.setsFor) return b.setsFor - a.setsFor;

    // 4) –∞–ª—Ñ–∞–≤–∏—Ç (—Å—Ç–∞–±–∏–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫, —á—Ç–æ–±—ã –Ω–µ –ø—Ä—ã–≥–∞–ª–æ)
    const pA = playersMap.get(a.playerId);
    const pB = playersMap.get(b.playerId);
    const nameA = pA ? `${pA.lastName} ${pA.firstName}` : "";
    const nameB = pB ? `${pB.lastName} ${pB.firstName}` : "";
    return nameA.localeCompare(nameB, "ru");
  });

  return standings;
}

// –í—Å–µ –ª–∏ –æ—Å–Ω–æ–≤–Ω—ã–µ (–Ω–µ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–æ—á–Ω—ã–µ) –º–∞—Ç—á–∏ –≤ –≥—Ä—É–ø–ø–µ —Å—ã–≥—Ä–∞–Ω—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
function areAllMainGroupMatchesCompleted(group) {
  const mainMatches = (group.matches || []).filter((m) => !m.isTiebreak);
  if (mainMatches.length === 0) return false;
  return mainMatches.every(
    (m) =>
      m.score1 != null &&
      m.score2 != null &&
      isValidScore(m.score1, m.score2)
  );
}

// ---------------------
// –ü–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤
// ---------------------

// –ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫—É –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤.
// –ò—â–µ–º –≥—Ä—É–ø–ø—ã –∏–≥—Ä–æ–∫–æ–≤ —Å –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏:
//   - –æ—á–∫–∞–º–∏
//   - —Ä–∞–∑–Ω–∏—Ü–µ–π —Å–µ—Ç–æ–≤
//   - –Ω–∞–±—Ä–∞–Ω–Ω—ã–º–∏ —Å–µ—Ç–∞–º–∏
// –ü–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∞ –Ω—É–∂–Ω–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–∞–∫–∞—è –≥—Ä—É–ø–ø–∞ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ—Ç –º–µ—Å—Ç–∞ 1‚Äì3.
function findMastersTiebreakCandidates(group) {
  const st = group.standings || [];
  if (st.length < 2) return [];

  // –∫–ª—é—á: "points|diff|setsFor" ‚Üí –º–∞—Å—Å–∏–≤ { row, index }
  const classes = new Map();

  st.forEach((row, index) => {
    const pts = row.points || 0;
    const diff = (row.setsFor || 0) - (row.setsAgainst || 0);
    const setsFor = row.setsFor || 0;
    const key = `${pts}|${diff}|${setsFor}`;
    if (!classes.has(key)) classes.set(key, []);
    classes.get(key).push({ row, index });
  });

  let bestClass = null;
  let bestMinIndex = Infinity;

  for (const groupEntries of classes.values()) {
    if (groupEntries.length <= 1) continue;
    const indices = groupEntries.map((e) => e.index);
    const minIndex = Math.min(...indices);

    // –ï—Å–ª–∏ –≥—Ä—É–ø–ø–∞ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ—Ç —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –º–µ—Å—Ç–æ –≤ —Ç–æ–ø-3 (–∏–Ω–¥–µ–∫—Å—ã 0,1,2),
    // –Ω–∞–º –≤–∞–∂–Ω–æ –µ—ë —Ä–∞–∑—Ä—É–ª–∏—Ç—å –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–æ–π.
    if (minIndex <= 2) {
      if (minIndex < bestMinIndex) {
        bestMinIndex = minIndex;
        bestClass = groupEntries;
      }
    }
  }

  if (!bestClass) return [];
  return bestClass.map((e) => e.row);
}

// –°–æ–∑–¥–∞–Ω–∏–µ –∫—Ä—É–≥–∞ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–æ–∫ "–∫–∞–∂–¥—ã–π —Å –∫–∞–∂–¥—ã–º" –º–µ–∂–¥—É —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –∏–≥—Ä–æ–∫–∞–º–∏
function createTiebreakMatchesForGroup(tournament, group, playerIds, roundIndex) {
  const base = createRoundRobinMatchesForGroup(tournament.id, group.id, playerIds);
  base.forEach((m) => {
    m.isTiebreak = true;
    m.tiebreakRound = roundIndex || 1;
  });
  return base;
}

// –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä—É–ø–ø—É –∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Å–æ–∑–¥–∞—ë–º / —Ç—Ä–µ–±—É–µ–º –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏.
// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç { needTiebreak: boolean, reason: "created" | "incomplete" | null }
function ensureMastersTiebreakMatches(group, tournament) {
  const allMatches = group.matches || [];
  const mainMatches = allMatches.filter((m) => !m.isTiebreak);
  const tbMatches = allMatches.filter((m) => m.isTiebreak);

  // 1) –ü–æ–∫–∞ –Ω–µ —Å—ã–≥—Ä–∞–Ω—ã –≤—Å–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –º–∞—Ç—á–∏ ‚Äî –Ω–∏–∫–∞–∫–∏—Ö –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–æ–∫.
  if (!areAllMainGroupMatchesCompleted(group)) {
    group.tiebreakInfo = null;
    if (tbMatches.length > 0) {
      // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π —á–∏—Å—Ç–∏–º —Å—Ç–∞—Ä—ã–µ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏, –µ—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–µ–Ω—è–ª–∞—Å—å
      group.matches = mainMatches;
    }
    return { needTiebreak: false, reason: null };
  }

  // 2) –ò—â–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –ø–æ –æ—á–∫–∞–º/—Ä–∞–∑–Ω–∏—Ü–µ/—Å–µ—Ç–∞–º
  const candidates = findMastersTiebreakCandidates(group);
  if (candidates.length <= 1) {
    // –†–∞–≤–µ–Ω—Å—Ç–≤–∞, –∑–∞—Ç—Ä–∞–≥–∏–≤–∞—é—â–µ–≥–æ —Ç–æ–ø-3, –±–æ–ª—å—à–µ –Ω–µ—Ç ‚Äî –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –Ω–µ –Ω—É–∂–Ω—ã.
    // –í–ê–ñ–ù–û: —Å–∞–º–∏ –º–∞—Ç—á–∏-–ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –Ω–µ —É–¥–∞–ª—è–µ–º, —á—Ç–æ–±—ã –∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    // —É—á–∏—Ç—ã–≤–∞–ª–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü–µ.
    group.tiebreakInfo = null;
    group.matches = allMatches;
    return { needTiebreak: false, reason: null };
  }

  const candidateIds = candidates.map((c) => c.playerId);

  // 3) –ï—Å—Ç—å –ª–∏ –Ω–µ–∑–∞–∫–æ–Ω—á–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –º–µ–∂–¥—É —ç—Ç–∏–º–∏ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞–º–∏
  const hasIncomplete = tbMatches.some(
    (m) =>
      candidateIds.includes(m.player1Id) &&
      candidateIds.includes(m.player2Id) &&
      (m.score1 == null || m.score2 == null)
  );

  if (hasIncomplete) {
    group.tiebreakInfo = {
      type: "masters",
      candidateIds,
      message: "–ù–µ –≤—Å–µ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤ —Å—ã–≥—Ä–∞–Ω—ã.",
    };
    return { needTiebreak: true, reason: "incomplete" };
  }

  // 4) –í—Å–µ –ø—Ä–µ–∂–Ω–∏–µ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –¥–æ–∏–≥—Ä–∞–Ω—ã, –Ω–æ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –æ—Å—Ç–∞–ª–æ—Å—å ‚Äî
  // —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –∫—Ä—É–≥ –º–µ–∂–¥—É —Ç–µ–º–∏ –∂–µ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞–º–∏
  let nextRound = 1;
  if (tbMatches.length > 0) {
    nextRound =
      Math.max(...tbMatches.map((m) => m.tiebreakRound || 1)) + 1;
  }

  const newMatches = createTiebreakMatchesForGroup(
    tournament,
    group,
    candidateIds,
    nextRound
  );

  group.matches = mainMatches.concat(tbMatches, newMatches);

  group.tiebreakInfo = {
    type: "masters",
    candidateIds,
    tiebreakRound: nextRound,
    message: "–°–æ–∑–¥–∞–Ω—ã –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤.",
  };

  return { needTiebreak: true, reason: "created" };
}

// ---------------------
// –õ–æ–≥–∏–∫–∞ –ø–ª–µ–π-–æ—Ñ—Ñ (–±—Ä–µ–∫–µ—Ç—ã)
// ---------------------

function computeRoundName(roundIndex, totalRounds) {
  const fromEnd = totalRounds - roundIndex;
  if (fromEnd === 1) return "–§–∏–Ω–∞–ª";
  if (fromEnd === 2) return "1/2 —Ñ–∏–Ω–∞–ª–∞";
  if (fromEnd === 3) return "1/4 —Ñ–∏–Ω–∞–ª–∞";
  if (fromEnd === 4) return "1/8 —Ñ–∏–Ω–∞–ª–∞";
  return `–†–∞—É–Ω–¥ ${roundIndex + 1}`;
}
// –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –º–∞—Ç—á–µ–π
function createBracketSkeleton(playersCount, stage) {
  const bracketSize = Math.pow(2, Math.ceil(Math.log2(playersCount)));
  const roundsCount = Math.log2(bracketSize);

  const rounds = [];

  for (let r = 0; r < roundsCount; r++) {
    const matchesCount = Math.pow(2, roundsCount - r - 1);
    const round = {
      id: generateId("round"),
      name: computeRoundName(r, roundsCount),
      matches: [],
      roundIndex: r,
    };

    for (let m = 0; m < matchesCount; m++) {
      round.matches.push({
        id: generateId("m"),
        roundId: round.id,
        player1Id: null,
        player2Id: null,
        score1: null,
        score2: null,
        nextMatchId: null,
        nextSlot: null,
        loserNextMatchId: null,
        loserNextSlot: null,
        stage,
      });
    }
    rounds.push(round);
  }

  // —Å–≤—è–∑–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π
  for (let r = 0; r < roundsCount - 1; r++) {
    const currentRound = rounds[r];
    const nextRound = rounds[r + 1];
    currentRound.matches.forEach((match, idx) => {
      const parentIdx = Math.floor(idx / 2);
      const parentMatch = nextRound.matches[parentIdx];
      match.nextMatchId = parentMatch.id;
      match.nextSlot = idx % 2 === 0 ? "p1" : "p2";
    });
  }

  // –º–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ
  let thirdPlaceRound = null;
  if (roundsCount >= 2) {
    const semiRound = rounds[roundsCount - 2];
    thirdPlaceRound = {
      id: generateId("round"),
      name: "–ú–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ",
      matches: [
        {
          id: generateId("m"),
          roundId: null,
          player1Id: null,
          player2Id: null,
          score1: null,
          score2: null,
          nextMatchId: null,
          nextSlot: null,
          loserNextMatchId: null,
          loserNextSlot: null,
          stage,
        },
      ],
    };
    thirdPlaceRound.matches[0].roundId = thirdPlaceRound.id;

    semiRound.matches.forEach((match, idx) => {
      match.loserNextMatchId = thirdPlaceRound.matches[0].id;
      match.loserNextSlot = idx === 0 ? "p1" : "p2";
    });
  }

  if (thirdPlaceRound) {
    rounds.push(thirdPlaceRound);
  }

  return { rounds, bracketSize, roundsCount };
}

function findMatchById(bracket, matchId) {
  for (const round of (bracket.rounds || [])) {
    for (const m of (round.matches || [])) {
      if (m.id === matchId) {
        return {
          match: m,
          round,
        };
      }
    }
  }
  return { match: null, round: null };
}

function autoAdvanceWinnerInBracket(bracket, match, winnerId) {
  if (!match.nextMatchId || !match.nextSlot) return;
  const { match: nextMatch } = findMatchById(bracket, match.nextMatchId);
  if (!nextMatch) return;
  if (match.nextSlot === "p1" && !nextMatch.player1Id) {
    nextMatch.player1Id = winnerId;
  } else if (match.nextSlot === "p2" && !nextMatch.player2Id) {
    nextMatch.player2Id = winnerId;
  }
}

// –ü—Ä–æ—Ç–∞–ª–∫–∏–≤–∞–µ–º –≤—Å–µ ¬´–∞–≤—Ç–æ–ø—Ä–æ—Ö–æ–¥—ã¬ª (–∫–æ–≥–¥–∞ –≤ –º–∞—Ç—á–µ –æ–¥–∏–Ω –∏–≥—Ä–æ–∫ –±–µ–∑ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞)
function propagateByes(bracket) {
  if (!bracket || !Array.isArray(bracket.rounds)) return;

  for (const round of bracket.rounds) {
    for (const match of round.matches || []) {
      const hasScore = match.score1 != null || match.score2 != null;
      const hasP1 = !!match.player1Id;
      const hasP2 = !!match.player2Id;

      if (!hasScore && ((hasP1 && !hasP2) || (!hasP1 && hasP2))) {
        const winnerId = hasP1 ? match.player1Id : match.player2Id;
        autoAdvanceWinnerInBracket(bracket, match, winnerId);
      }
    }
  }
}

// players: [{ id, priority, seedScore?, groupId?, place? }]
function assignPlayersToBracket(bracket, players) {
  const B = bracket.bracketSize;
  const firstRound = bracket.rounds[0];
  const matchesCount = firstRound.matches.length;
  const stage = firstRound.matches[0]?.stage || null; // "masters" | "challenge"

  // –Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–Ω–¥–æ–º –¥–ª—è —Ä–∞–∑—Ä—É–ª–∏–≤–∞–Ω–∏—è –ø–æ–ª–Ω—ã—Ö —Ä–∞–≤–µ–Ω—Å—Ç–≤
  const shuffled = [...players];
  shuffleInPlace(shuffled);

  const N = shuffled.length;
  const byesCount = B - N;

  // --- 1. –í—ã–±–∏—Ä–∞–µ–º, –∫—Ç–æ –ø–æ–ª—É—á–∞–µ—Ç BYE ---
  const sortedForByes = [...shuffled].sort((a, b) => {
    const pa = a.priority ?? 999;
    const pb = b.priority ?? 999;
    if (pa !== pb) return pa - pb;

    const sa = a.seedScore ?? 0;
    const sb = b.seedScore ?? 0;
    return sb - sa;
  });

  const byeRecipients =
    byesCount > 0 ? sortedForByes.slice(0, byesCount) : [];
  const byeIds = new Set(byeRecipients.map((p) => p.id));

  // –ò–≥—Ä–æ–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∞–ª—å–Ω–æ –∏–≥—Ä–∞—é—Ç –≤ –ø–µ—Ä–≤–æ–º —Ä–∞—É–Ω–¥–µ
  const playing = shuffled.filter((p) => !byeIds.has(p.id));

  // –ó–∞–≥–æ—Ç–æ–≤–∫–∞ —Å–ª–æ—Ç–æ–≤ –º–∞—Ç—á–µ–π –ø–µ—Ä–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞
  const matchesSlots = Array.from({ length: matchesCount }, () => ({
    p1: null,
    p2: null,
  }));

  // --- 2. –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º BYE ---
  const freeMatchIndices = Array.from({ length: matchesCount }, (_, i) => i);
  shuffleInPlace(freeMatchIndices);

  byeRecipients.forEach((p, idx) => {
    if (idx >= freeMatchIndices.length) return;
    const mi = freeMatchIndices[idx];
    const slotName = Math.random() < 0.5 ? "p1" : "p2";
    matchesSlots[mi][slotName] = p.id;
  });

  function popFrom(arr, predicate) {
    if (!arr.length) return null;
    if (!predicate) {
      return arr.shift();
    }
    const idx = arr.findIndex(predicate);
    if (idx === -1) return null;
    const [item] = arr.splice(idx, 1);
    return item;
  }

  // -----------------------------
  // –í–ï–¢–ö–ê A: –ö–£–ë–û–ö –í–´–ó–û–í–ê
  // -----------------------------
  if (stage === "challenge") {
    const tier3 = playing.filter((p) => p.place === 3);
    const tier4 = playing.filter((p) => p.place === 4);
    const tier5 = playing.filter((p) => p.place === 5);

    shuffleInPlace(tier3);
    shuffleInPlace(tier4);
    shuffleInPlace(tier5);

    for (let i = 0; i < matchesCount; i++) {
      const slot = matchesSlots[i];

      if (
        (slot.p1 && byeIds.has(slot.p1)) ||
        (slot.p2 && byeIds.has(slot.p2))
      ) {
        continue;
      }

      if (slot.p1 && slot.p2) continue;

      if (!slot.p1 && !slot.p2) {
        let a = null;
        let b = null;

        let arrA = null;
        if (tier3.length >= 2) arrA = tier3;
        else if (tier4.length >= 2) arrA = tier4;
        else if (tier5.length >= 2) arrA = tier5;

        if (arrA) {
          a = popFrom(arrA);
          b =
            popFrom(arrA, (p) => p.groupId !== a.groupId) ||
            popFrom(arrA);
        } else {
          a = popFrom(tier3) || popFrom(tier4) || popFrom(tier5);
          b = popFrom(tier3) || popFrom(tier4) || popFrom(tier5);
        }

        if (a) slot.p1 = a.id;
        if (b) slot.p2 = b?.id ?? slot.p2;
      } else {
        const takenId = slot.p1 || slot.p2;
        const taken =
          tier3.find((p) => p.id === takenId) ||
          tier4.find((p) => p.id === takenId) ||
          tier5.find((p) => p.id === takenId) ||
          null;

        let other = null;

        if (taken) {
          let arrPref =
            taken.place === 3 ? tier3 : taken.place === 4 ? tier4 : tier5;

          other =
            popFrom(arrPref, (p) => p.groupId !== taken.groupId) ||
            popFrom(arrPref) ||
            popFrom(tier3, (p) => p.groupId !== taken.groupId) ||
            popFrom(tier4, (p) => p.groupId !== taken.groupId) ||
            popFrom(tier5, (p) => p.groupId !== taken.groupId) ||
            popFrom(tier3) ||
            popFrom(tier4) ||
            popFrom(tier5);
        } else {
          other = popFrom(tier3) || popFrom(tier4) || popFrom(tier5);
        }

        if (!slot.p1 && other) slot.p1 = other.id;
        else if (!slot.p2 && other) slot.p2 = other.id;
      }
    }
  } else {
    // -----------------------------
    // –í–ï–¢–ö–ê B: –ö–£–ë–û–ö –ú–ê–°–¢–ï–†–û–í
    // -----------------------------
    const firsts = playing.filter((p) => p.priority === 1);
    const seconds = playing.filter((p) => p.priority !== 1);

    for (let i = 0; i < matchesCount; i++) {
      const slot = matchesSlots[i];

      if (
        (slot.p1 && byeIds.has(slot.p1)) ||
        (slot.p2 && byeIds.has(slot.p2))
      ) {
        continue;
      }

      if (slot.p1 && slot.p2) continue;

      if (!slot.p1 && !slot.p2) {
        let a = null;
        let b = null;

        if (firsts.length && seconds.length) {
          const firstSide = firsts.length >= seconds.length ? "first" : "second";

          if (firstSide === "first") {
            a = popFrom(firsts);
            b =
              popFrom(seconds, (p) => p.groupId !== a.groupId) ||
              popFrom(seconds) ||
              popFrom(firsts, (p) => p.groupId !== a.groupId) ||
              popFrom(firsts);
          } else {
            a = popFrom(seconds);
            b =
              popFrom(firsts, (p) => p.groupId !== a.groupId) ||
              popFrom(firsts) ||
              popFrom(seconds, (p) => p.groupId !== a.groupId) ||
              popFrom(seconds);
          }
        } else if (firsts.length >= 2) {
          a = popFrom(firsts);
          b =
            popFrom(firsts, (p) => p.groupId !== a.groupId) ||
            popFrom(firsts);
        } else if (seconds.length >= 2) {
          a = popFrom(seconds);
          b =
            popFrom(seconds, (p) => p.groupId !== a.groupId) ||
            popFrom(seconds);
        } else {
          a = popFrom(firsts) || popFrom(seconds);
          b = popFrom(firsts) || popFrom(seconds);
        }

        if (a) slot.p1 = a.id;
        if (b) slot.p2 = b?.id ?? slot.p2;
      } else {
        const takenId = slot.p1 || slot.p2;
        const findAll = [...firsts, ...seconds];
        const taken = findAll.find((p) => p.id === takenId) || null;

        let other = null;
        if (taken) {
          if (taken.priority === 1) {
            other =
              popFrom(seconds, (p) => p.groupId !== taken.groupId) ||
              popFrom(seconds) ||
              popFrom(firsts, (p) => p.groupId !== taken.groupId) ||
              popFrom(firsts);
          } else {
            other =
              popFrom(firsts, (p) => p.groupId !== taken.groupId) ||
              popFrom(firsts) ||
              popFrom(seconds, (p) => p.groupId !== taken.groupId) ||
              popFrom(seconds);
          }
        } else {
          other = popFrom(firsts) || popFrom(seconds);
        }

        if (!slot.p1 && other) slot.p1 = other.id;
        else if (!slot.p2 && other) slot.p2 = other.id;
      }
    }
  }

  // --- 4. –ü–µ—Ä–µ–Ω–æ—Å–∏–º –≤ –º–∞—Ç—á–∏ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–ø—Ä–æ—Ö–æ–¥ BYE ---
  for (let i = 0; i < firstRound.matches.length; i++) {
    const match = firstRound.matches[i];
    const slot = matchesSlots[i];

    match.player1Id = slot.p1 || null;
    match.player2Id = slot.p2 || null;

    if (match.player1Id && !match.player2Id) {
      autoAdvanceWinnerInBracket(bracket, match, match.player1Id);
    } else if (!match.player1Id && match.player2Id) {
      autoAdvanceWinnerInBracket(bracket, match, match.player2Id);
    }
  }
}

function applyPlayoffResultToBracket(bracket, match, winnerId, loserId) {
  if (match.nextMatchId && match.nextSlot) {
    const { match: nextMatch } = findMatchById(bracket, match.nextMatchId);
    if (nextMatch) {
      if (match.nextSlot === "p1") {
        nextMatch.player1Id = winnerId;
      } else {
        nextMatch.player2Id = winnerId;
      }
    }
  }
  if (match.loserNextMatchId && match.loserNextSlot) {
    const { match: nextMatch } = findMatchById(
      bracket,
      match.loserNextMatchId
    );
    if (nextMatch) {
      if (match.loserNextSlot === "p1") {
        nextMatch.player1Id = loserId;
      } else {
        nextMatch.player2Id = loserId;
      }
    }
  }
}

// –°–ª—É–∂–µ–±–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —Å–∫—Ä—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ "–ª–∏—à–Ω–∏–µ" –º–∞—Ç—á–∏ —Å –∞–≤—Ç–æ–ø—Ä–æ—Ö–æ–¥–æ–º
function shouldHideByeMatch(match, round) {
  const hasP1 = !!match.player1Id;
  const hasP2 = !!match.player2Id;

  const isFirstRound =
    round && (round.roundIndex === 0 || /^–†–∞—É–Ω–¥\s*1$/i.test(round.name || ""));

  if (
    isFirstRound &&
    ((hasP1 && !hasP2) || (!hasP1 && hasP2))
  ) {
    return true;
  }

  if (isFirstRound && !hasP1 && !hasP2) {
    return true;
  }

  return false;
}

function createBracketFromPlayers(playersWithPriority, stage) {
  if (!playersWithPriority || playersWithPriority.length < 2) return null;

  const skeleton = createBracketSkeleton(playersWithPriority.length, stage);
  assignPlayersToBracket(skeleton, playersWithPriority);

  // –ë–û–õ–¨–®–ï –ù–ï –ü–†–û–¢–ê–õ–ö–ò–í–ê–ï–ú BYE –ü–û –í–°–ï–ô –°–ï–¢–ö–ï,
  // –∞–≤—Ç–æ-–ø—Ä–æ—Ö–æ–¥ –¥–µ–ª–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞ –≤ assignPlayersToBracket

  return {
    players: playersWithPriority.map((p) => p.id),
    rounds: skeleton.rounds,
  };
}

// –ß–µ–º –≤—ã—à–µ seedScore, —Ç–µ–º "—Å–∏–ª—å–Ω–µ–µ" –∏–≥—Ä–æ–∫ –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º –≥—Ä—É–ø–ø—ã
function computeSeedScore(row) {
  if (!row) return 0;
  const diff = (row.setsFor || 0) - (row.setsAgainst || 0);
  const points = row.points || 0;
  const setsFor = row.setsFor || 0;

  return points * 10000 + diff * 100 + setsFor;
}

// –î–ª—è –ö—É–±–∫–∞ –º–∞—Å—Ç–µ—Ä–æ–≤: 1-–µ –∏ 2-–µ –º–µ—Å—Ç–∞.
function createMastersPlayersFromGroups(groups, standingsByGroup) {
  const players = [];

  for (const group of groups) {
    const st = standingsByGroup.get(group.id) || [];

    if (st[0]) {
      players.push({
        id: st[0].playerId,
        groupId: group.id,
        priority: 1,
        seedScore: computeSeedScore(st[0]),
      });
    }

    if (st[1]) {
      players.push({
        id: st[1].playerId,
        groupId: group.id,
        priority: 2,
        seedScore: computeSeedScore(st[1]),
      });
    }
  }

  return players;
}

// –î–ª—è –ö—É–±–∫–∞ –≤—ã–∑–æ–≤–∞: 3‚Äì5 –º–µ—Å—Ç–∞
function createChallengePlayersFromGroups(groups, standingsByGroup) {
  const players = [];

  for (const group of groups) {
    const st = standingsByGroup.get(group.id) || [];

    if (st[2]) {
      players.push({
        id: st[2].playerId,
        groupId: group.id,
        place: 3,
        priority: 1,
        seedScore: computeSeedScore(st[2]),
      });
    }

    if (st[3]) {
      players.push({
        id: st[3].playerId,
        groupId: group.id,
        place: 4,
        priority: 2,
        seedScore: computeSeedScore(st[3]),
      });
    }

    if (st[4]) {
      players.push({
        id: st[4].playerId,
        groupId: group.id,
        place: 5,
        priority: 3,
        seedScore: computeSeedScore(st[4]),
      });
    }
  }

  return players;
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ–¥–∞–ª–∏—Å—Ç–æ–≤ –ø–æ –±—Ä–µ–∫–µ—Ç—É
function extractWinnersFromBracket(bracket) {
  if (!bracket || !bracket.rounds || !bracket.rounds.length) {
    return {
      gold: null,
      silver: null,
      bronze: null,
    };
  }
  const finalRound = bracket.rounds.find((r) => r.name === "–§–∏–Ω–∞–ª");
  let gold = null;
  let silver = null;
  let bronze = null;

  if (finalRound && finalRound.matches[0]) {
    const m = finalRound.matches[0];
    if (isValidScore(m.score1, m.score2)) {
      const res = getWinnerLoser(m.score1, m.score2, m.player1Id, m.player2Id);
      if (res) {
        gold = res.winnerId;
        silver = res.loserId;
      }
    }
  }

  const thirdPlaceRound = bracket.rounds.find(
    (r) => r.name === "–ú–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ"
  );
  if (thirdPlaceRound && thirdPlaceRound.matches[0]) {
    const m = thirdPlaceRound.matches[0];
    if (isValidScore(m.score1, m.score2)) {
      const res = getWinnerLoser(m.score1, m.score2, m.player1Id, m.player2Id);
      if (res) {
        bronze = res.winnerId;
      }
    }
  }

  return { gold, silver, bronze };
}

// –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –º–µ–¥–∞–ª–µ–π –∏ —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
function collectTournamentResults(tournament) {
  const po = tournament.playoffs || {};
  const mastersBracket = po.mastersBracket;
  const challengeBracket = po.challengeBracket;

  const medals = new Map(); // id -> ü•á/ü•à/ü•â
  const resultLabels = new Map(); // id -> —Ç–µ–∫—Å—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

  function prettyRoundName(name) {
    if (name === "1/2 —Ñ–∏–Ω–∞–ª–∞") return "–ü–æ–ª—É—Ñ–∏–Ω–∞–ª";
    return name;
  }

  function applyMedals(bracket, cupLabel) {
    if (!bracket) return;
    const { gold, silver, bronze } = extractWinnersFromBracket(bracket);
    if (gold) {
      medals.set(gold, "ü•á");
      resultLabels.set(gold, `1 –º–µ—Å—Ç–æ (${cupLabel})`);
    }
    if (silver) {
      medals.set(silver, "ü•à");
      resultLabels.set(silver, `2 –º–µ—Å—Ç–æ (${cupLabel})`);
    }
    if (bronze) {
      medals.set(bronze, "ü•â");
      resultLabels.set(bronze, `3 –º–µ—Å—Ç–æ (${cupLabel})`);
    }
  }

  applyMedals(mastersBracket, "–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤");
  applyMedals(challengeBracket, "–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞");

  const elimInfo = new Map(); // id -> { priority, roundName, cupLabel }
  const inAnyPlayoff = new Set();

  function stagePriority(name) {
    if (!name) return 0;
    if (name.includes("1/8")) return 1;
    if (name.includes("1/4")) return 2;
    if (name.includes("1/2")) return 3;
    if (name === "–§–∏–Ω–∞–ª") return 4;
    if (name.includes("–ú–∞—Ç—á –∑–∞ 3")) return 3.5;
    return 0.5;
  }

  function registerElimination(pid, roundName, cupLabel) {
    if (!pid) return;
    if (medals.has(pid)) return;
    const pr = stagePriority(roundName);
    const prev = elimInfo.get(pid);
    if (!prev || prev.priority < pr) {
      elimInfo.set(pid, { priority: pr, roundName, cupLabel });
    }
  }

  function processBracketElim(bracket, cupLabel) {
    if (!bracket || !bracket.rounds) return;
    for (const round of bracket.rounds) {
      for (const match of round.matches || []) {
        if (match.score1 == null || match.score2 == null) continue;
        if (!isValidScore(match.score1, match.score2)) continue;
        const res = getWinnerLoser(
          match.score1,
          match.score2,
          match.player1Id,
          match.player2Id
        );
        if (!res) continue;
        const { winnerId, loserId } = res;
        if (winnerId) inAnyPlayoff.add(winnerId);
        if (loserId) {
          inAnyPlayoff.add(loserId);
          registerElimination(loserId, round.name, cupLabel);
        }
      }
    }
  }

  processBracketElim(mastersBracket, "–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤");
  processBracketElim(challengeBracket, "–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞");

  elimInfo.forEach((info, pid) => {
    if (!resultLabels.has(pid)) {
      const niceName = prettyRoundName(info.roundName);
      resultLabels.set(pid, `${niceName} (${info.cupLabel})`);
    }
  });

  const groups = tournament.groups || [];
  const inGroups = new Set();
  groups.forEach((g) => {
    (g.playerIds || []).forEach((pid) => inGroups.add(pid));
  });

  inGroups.forEach((pid) => {
    if (!resultLabels.has(pid) && !inAnyPlayoff.has(pid)) {
      resultLabels.set(pid, "–ì—Ä—É–ø–ø–æ–≤–æ–π —ç—Ç–∞–ø");
    }
  });

  (tournament.players || []).forEach((p) => {
    if (!resultLabels.has(p.id)) {
      resultLabels.set(p.id, "–£—á–∞—Å—Ç–Ω–∏–∫");
    }
  });

  return { medals, resultLabels };
}

// ---------------------
// –†–µ–Ω–¥–µ—Ä –ü—É–±–ª–∏—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
// ---------------------

function renderPublicPage() {
  const root = document.getElementById("public-root");
  if (!root) return;

  const state = currentState;
  const t = getActiveTournament(state);

  if (!t) {
    root.innerHTML = `
      <div class="lp-card">
        <div class="lp-card-header">
          <h2 class="lp-card-title">–¢—É—Ä–Ω–∏—Ä –ø–æ–∫–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω</h2>
        </div>
        <p class="lp-text-muted">–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä—É, —á—Ç–æ–±—ã –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏ —Å–æ–∑–¥–∞—Ç—å –∏ –≤—ã–±—Ä–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π —Ç—É—Ä–Ω–∏—Ä.</p>
      </div>
    `;
    return;
  }

  const tournament = ensureTournamentShape(t);
  const playersMap = new Map(tournament.players.map((p) => [p.id, p]));

  const regStatus = tournament.registrationOpen
    ? "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∞"
    : "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–∫—Ä—ã—Ç–∞";
  const regBadgeClass = tournament.registrationOpen
    ? "lp-badge lp-badge-status-open"
    : "lp-badge lp-badge-gray";

  // ===== –ë–ª–æ–∫ ¬´–æ–ø–∏—Å–∞–Ω–∏–µ + —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è¬ª =====
  let html = `
    <section id="section-registration" class="lp-grid-2">
      <div class="lp-card">
        <div class="lp-card-header">
          <div>
            <h2 class="lp-card-title">${escapeHtml(
              tournament.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
            )}</h2>
            <p class="lp-card-subtitle">–°—Ç–∞—Ç—É—Å: ${
              tournament.status === "registration"
                ? "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è"
                : tournament.status === "groups"
                ? "–ì—Ä—É–ø–ø–æ–≤–æ–π —ç—Ç–∞–ø"
                : "–ü–ª–µ–π-–æ—Ñ—Ñ"
            }</p>
          </div>
          <span class="${regBadgeClass}">${regStatus}</span>
        </div>
        <div class="lp-separator"></div>
        <p class="lp-text-muted lp-text-xs">
          –£—á–∞—Å—Ç–Ω–∏–∫–∏ ‚Äî —Ç–æ–ª—å–∫–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ –º–∞–≥–∞–∑–∏–Ω–∞. –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ 
          –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä—ã —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è—Ç –∏–≥—Ä–æ–∫–æ–≤ –ø–æ –≥—Ä—É–ø–ø–∞–º, –∑–∞—Ç–µ–º –Ω–∞—á–Ω—ë—Ç—Å—è –ø–ª–µ–π-–æ—Ñ—Ñ.
        </p>
      </div>

      <div class="lp-card">
        <div class="lp-card-header">
          <h3 class="lp-card-title">–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞</h3>
        </div>
  `;

  if (!tournament.registrationOpen) {
    html += `
      <p class="lp-text-muted">–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–∫—Ä—ã—Ç–∞. –î–æ–∂–¥–∏—Ç–µ—Å—å —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ç—É—Ä–Ω–∏—Ä–∞ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä—É.</p>
    `;
  } else {
    html += `
      <form id="public-registration-form" class="lp-form">
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <div style="flex:1 1 120px; min-width:120px;">
            <label class="lp-text-xs">–ò–º—è</label>
            <input type="text" name="firstName" class="lp-input" placeholder="–ò–≤–∞–Ω" required />
          </div>
          <div style="flex:1 1 120px; min-width:120px;">
            <label class="lp-text-xs">–§–∞–º–∏–ª–∏—è</label>
            <input type="text" name="lastName" class="lp-input" placeholder="–ò–≤–∞–Ω–æ–≤" required />
          </div>
          <div style="flex:1 1 120px; min-width:120px;">
            <label class="lp-text-xs">LDAP <span style="color:#ff8;">*</span></label>
            <input type="text" name="ldap" class="lp-input" placeholder="–∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –ª–æ–≥–∏–Ω" required />
          </div>
        </div>
        <div style="margin-top:10px; display:flex; justify-content:flex-end;">
          <button type="submit" class="lp-btn lp-btn-primary lp-btn-sm">
            –ó–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Ç—É—Ä–Ω–∏—Ä
          </button>
        </div>
      </form>
      <p class="lp-text-muted lp-text-xs" style="margin-top:6px;">
        –ü–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ä–º—ã –≤—ã –ø–æ—è–≤–∏—Ç–µ—Å—å –≤ —Å–ø–∏—Å–∫–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤. –ò–∑–º–µ–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–∞.
      </p>
    `;
  }

  html += `</div></section>`;

  // ===== –ì—Ä—É–ø–ø–æ–≤–æ–π —ç—Ç–∞–ø =====
  if (tournament.groups && tournament.groups.length > 0) {
    html += `
      <section id="section-groups" class="lp-card">
        <div class="lp-card-header">
          <h3 class="lp-card-title">–ì—Ä—É–ø–ø–æ–≤–æ–π —ç—Ç–∞–ø</h3>
          <span class="lp-pill"><span class="lp-pill-dot"></span> –ü–∞—Ä—ã ¬´–∫–∞–∂–¥—ã–π —Å –∫–∞–∂–¥—ã–º¬ª</span>
        </div>
        <p class="lp-card-subtitle">
          –ü–æ–±–µ–¥–∞ 2:0 ‚Äî 3 –æ—á–∫–∞; –ø–æ–±–µ–¥–∞ 2:1 ‚Äî 2 –æ—á–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—é –∏ 1 –æ—á–∫–æ –ø—Ä–æ–∏–≥—Ä–∞–≤—à–µ–º—É. 
          –í —Å–∫–æ–±–∫–∞—Ö ‚Äî —Ä–∞–∑–Ω–∏—Ü–∞ —Å–µ—Ç–æ–≤.
        </p>
        <div class="lp-groups-grid">
    `;

    for (let i = 0; i < tournament.groups.length; i++) {
      const g = tournament.groups[i];
      const standings = g.standings || [];

      const allMatches = g.matches || [];
      const mainMatches = allMatches.filter((m) => !m.isTiebreak);
      const tiebreakMatches = allMatches.filter((m) => m.isTiebreak);

      html += `
        <div class="lp-group-card lp-group-card--public">
          <div class="lp-group-header-line">
            <span class="lp-group-name">–ì—Ä—É–ø–ø–∞ ${i + 1}</span>
          </div>
          <div class="lp-table-scroll">
            <table class="lp-table lp-table--sticky-name">
              <thead>
                <tr>
                  <th>–ò–≥—Ä–æ–∫</th>
                  <th>–°–µ—Ç—ã</th>
                  <th>(+/‚àí)</th>
                  <th>–ü–æ–±–µ–¥—ã</th>
                  <th>–ü–æ—Ä–∞–∂–µ–Ω–∏—è</th>
                  <th>–û—á–∫–∏</th>
                </tr>
              </thead>
              <tbody>
      `;

      for (let j = 0; j < standings.length; j++) {
        const row = standings[j];
        const player = playersMap.get(row.playerId);
        const name = player
          ? `${escapeHtml(player.firstName)} ${escapeHtml(player.lastName)}`
          : "‚Äî";
        const diff = row.setsFor - row.setsAgainst;
        const diffText = diff > 0 ? `+${diff}` : `${diff}`;
        const highlight = j === 0 || j === 1 ? "lp-table-row-highlight" : "";

        html += `
          <tr class="${highlight}">
            <td>${name}</td>
            <td>${row.setsFor}:${row.setsAgainst}</td>
            <td>${diffText}</td>
            <td>${row.wins}</td>
            <td>${row.losses}</td>
            <td>${row.points}</td>
          </tr>
        `;
      }

      html += `
              </tbody>
            </table>
          </div>
      `;

      if (mainMatches.length > 0) {
        html += `
          <div class="lp-card-section-title" style="margin-top:10px;">–ú–∞—Ç—á–∏ –≥—Ä—É–ø–ø—ã</div>
          <div class="lp-matches-list">
        `;

        for (const m of mainMatches) {
          const p1 = playersMap.get(m.player1Id);
          const p2 = playersMap.get(m.player2Id);
          const name1 = p1
            ? `${escapeHtml(p1.firstName)} ${escapeHtml(p1.lastName)}`
            : "‚Äî";
          const name2 = p2
            ? `${escapeHtml(p2.firstName)} ${escapeHtml(p2.lastName)}`
            : "‚Äî";

          const hasScore = m.score1 != null && m.score2 != null;
          const scoreText = hasScore ? `${m.score1}:${m.score2}` : "‚Äî : ‚Äî";

          let winnerClass1 = "";
          let winnerClass2 = "";
          if (hasScore && isValidScore(m.score1, m.score2)) {
            const res = getWinnerLoser(
              m.score1,
              m.score2,
              m.player1Id,
              m.player2Id
            );
            if (res) {
              if (res.winnerId === m.player1Id) winnerClass1 = "lp-match-winner";
              if (res.winnerId === m.player2Id) winnerClass2 = "lp-match-winner";
            }
          }

          const scoreClass = hasScore
            ? "lp-match-score"
            : "lp-match-score lp-text-muted";

          html += `
            <div class="lp-match-row">
              <div class="lp-match-player lp-match-player--left ${winnerClass1}">
                ${name1}
              </div>
              <div class="${scoreClass}">
                ${scoreText}
              </div>
              <div class="lp-match-player lp-match-player--right ${winnerClass2}">
                ${name2}
              </div>
            </div>
          `;
        }

        html += `</div>`;
      }

      // –ü–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏, –µ—Å–ª–∏ –µ—Å—Ç—å
      if (tiebreakMatches.length > 0) {
        html += `
          <div class="lp-card-section-title" style="margin-top:10px;">
            –ü–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤
          </div>
          <div class="lp-matches-list lp-matches-list--tiebreaks">
        `;

        for (const m of tiebreakMatches) {
          const p1 = playersMap.get(m.player1Id);
          const p2 = playersMap.get(m.player2Id);
          const name1 = p1
            ? `${escapeHtml(p1.firstName)} ${escapeHtml(p1.lastName)}`
            : "‚Äî";
          const name2 = p2
            ? `${escapeHtml(p2.firstName)} ${escapeHtml(p2.lastName)}`
            : "‚Äî";

          const hasScore = m.score1 != null && m.score2 != null;
          const scoreText = hasScore ? `${m.score1}:${m.score2}` : "‚Äî : ‚Äî";

          let winnerClass1 = "";
          let winnerClass2 = "";
          if (hasScore && isValidScore(m.score1, m.score2)) {
            const res = getWinnerLoser(
              m.score1,
              m.score2,
              m.player1Id,
              m.player2Id
            );
            if (res) {
              if (res.winnerId === m.player1Id) winnerClass1 = "lp-match-winner";
              if (res.winnerId === m.player2Id) winnerClass2 = "lp-match-winner";
            }
          }

          const scoreClass = hasScore
            ? "lp-match-score"
            : "lp-match-score lp-text-muted";

          html += `
            <div class="lp-match-row">
              <div class="lp-match-player lp-match-player--left ${winnerClass1}">
                ${name1}
              </div>
              <div class="${scoreClass}">
                ${scoreText}
              </div>
              <div class="lp-match-player lp-match-player--right ${winnerClass2}">
                ${name2}
              </div>
            </div>
          `;
        }

        html += `</div>`;
      }

      html += `</div>`;
    }

    html += `
        </div>
      </section>
    `;
  }

  // –ü–ª–µ–π-–æ—Ñ—Ñ
  html += renderPublicPlayoffs(tournament);

  // –£—á–∞—Å—Ç–Ω–∏–∫–∏
  html += renderPublicParticipantsSection(tournament);

  root.innerHTML = html;

  const form = document.getElementById("public-registration-form");
  if (form) {
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      const formData = new FormData(form);
      const firstName = String(formData.get("firstName") || "").trim();
      const lastName = String(formData.get("lastName") || "").trim();
      const ldap = String(formData.get("ldap") || "").trim();
      if (!firstName || !lastName || !ldap) {
        alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è.");
        return;
      }
      handlePublicRegisterPlayer(firstName, lastName, ldap);
      form.reset();
    });
  }
}


// ---------------------
// –ü–ª–µ–π-–æ—Ñ—Ñ (–ø—É–±–ª–∏—á–Ω–∞—è)
// ---------------------

function renderPublicPlayoffs(tournament) {
  const playersMap = new Map(tournament.players.map((p) => [p.id, p]));

  const mastersBracket = tournament.playoffs.mastersBracket;
  const challengeBracket = tournament.playoffs.challengeBracket;

  if (!mastersBracket && !challengeBracket) return "";

  let html = `
    <section id="section-playoffs" class="lp-card">
      <div class="lp-card-header">
        <h3 class="lp-card-title">–ü–ª–µ–π-–æ—Ñ—Ñ</h3>
        <span class="lp-pill">
          <span class="lp-pill-dot"></span>
          –ò–≥—Ä—ã –Ω–∞ –≤—ã–ª–µ—Ç –¥–æ –¥–≤—É—Ö –ø–æ–±–µ–¥
        </span>
      </div>
      <div class="lp-playoffs-grid">
  `;

  if (mastersBracket) {
    html += `
      <div class="lp-playoffs-block">
        <h4 class="lp-card-section-title">–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤</h4>
        <div class="lp-bracket">
          ${renderBracket(mastersBracket, playersMap)}
        </div>
      </div>
    `;
  }

  if (challengeBracket) {
    html += `
      <div class="lp-playoffs-block">
        <h4 class="lp-card-section-title">–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞</h4>
        <div class="lp-bracket">
          ${renderBracket(challengeBracket, playersMap)}
        </div>
      </div>
    `;
  }

  html += `
      </div>
    </section>
  `;

  return html;
}


function renderBracket(bracket, playersMap) {
  if (!bracket || !bracket.rounds || bracket.rounds.length === 0) {
    return `<p class="lp-text-muted lp-text-xs">–°–µ—Ç–∫–∞ –µ—â—ë –Ω–µ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∞.</p>`;
  }

  let html = `<div class="lp-bracket-inner">`;
  for (const round of bracket.rounds) {
    const isFinal = round.name === "–§–∏–Ω–∞–ª";
    const isThird = round.name === "–ú–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ";
    const roundClass = isFinal
      ? "lp-bracket-round lp-bracket-round--final"
      : isThird
      ? "lp-bracket-round lp-bracket-round--third"
      : "lp-bracket-round";

    html += `<div class="${roundClass}">
      <div class="lp-bracket-round-title">${escapeHtml(round.name)}</div>
    `;
    for (const match of round.matches) {
      if (shouldHideByeMatch(match, round)) continue;

      const p1 = playersMap.get(match.player1Id);
      const p2 = playersMap.get(match.player2Id);
      const name1 = p1
        ? `${escapeHtml(p1.firstName)} ${escapeHtml(p1.lastName)}`
        : "‚Äî";
      const name2 = p2
        ? `${escapeHtml(p2.firstName)} ${escapeHtml(p2.lastName)}`
        : "‚Äî";

      let p1Class = "lp-bracket-player-name";
      let p2Class = "lp-bracket-player-name";

      if (match.score1 != null && match.score2 != null) {
        if (isValidScore(match.score1, match.score2)) {
          const res = getWinnerLoser(
            match.score1,
            match.score2,
            match.player1Id,
            match.player2Id
          );
          if (res) {
            if (res.winnerId === match.player1Id) {
              p1Class += " lp-bracket-player--winner";
            } else if (res.winnerId === match.player2Id) {
              p2Class += " lp-bracket-player--winner";
            }
          }
        }
      }

      const score1 =
        match.score1 != null && match.score2 != null
          ? String(match.score1)
          : "";
      const score2 =
        match.score1 != null && match.score2 != null
          ? String(match.score2)
          : "";

      html += `
        <div class="lp-bracket-match">
          <div class="lp-bracket-player-row">
            <span class="${p1Class}">${name1}</span>
            <span class="lp-bracket-player-score">${score1}</span>
          </div>
          <div class="lp-bracket-player-row">
            <span class="${p2Class}">${name2}</span>
            <span class="lp-bracket-player-score">${score2}</span>
          </div>
        </div>
      `;
    }
    html += `</div>`;
  }
  html += `</div>`;
  return html;
}
// ---------------------
// –ü—å–µ–¥–µ—Å—Ç–∞–ª + —É—á–∞—Å—Ç–Ω–∏–∫–∏
// ---------------------

function renderPodium(title, winners, playersMap) {
  const { gold, silver, bronze } = winners;

  if (!gold && !silver && !bronze) {
    return `
      <div class="lp-podium-block">
        <h4 class="lp-card-section-title">${escapeHtml(title)}</h4>
        <p class="lp-text-muted lp-text-xs">–ò—Ç–æ–≥–æ–≤—ã–µ –º–µ—Å—Ç–∞ –±—É–¥—É—Ç –ø–æ–∫–∞–∑–∞–Ω—ã –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–ª–µ–π-–æ—Ñ—Ñ.</p>
      </div>
    `;
  }

  function nameOf(id) {
    const p = playersMap.get(id);
    if (!p) return "‚Äî";
    return `${escapeHtml(p.firstName)} ${escapeHtml(p.lastName)}`;
  }

  return `
    <div class="lp-podium-block">
      <h4 class="lp-card-section-title">${escapeHtml(title)}</h4>
      <div class="lp-podium">
        <div class="lp-podium-item lp-podium-2">
          <div class="lp-podium-medal">ü•à</div>
          <div class="lp-podium-place">2 –º–µ—Å—Ç–æ</div>
          <div class="lp-podium-name">${silver ? nameOf(silver) : "‚Äî"}</div>
        </div>
        <div class="lp-podium-item lp-podium-1">
          <div class="lp-podium-medal lp-podium-medal--gold">ü•á</div>
          <div class="lp-podium-place">1 –º–µ—Å—Ç–æ</div>
          <div class="lp-podium-name">${gold ? nameOf(gold) : "‚Äî"}</div>
        </div>
        <div class="lp-podium-item lp-podium-3">
          <div class="lp-podium-medal">ü•â</div>
          <div class="lp-podium-place">3 –º–µ—Å—Ç–æ</div>
          <div class="lp-podium-name">${bronze ? nameOf(bronze) : "‚Äî"}</div>
        </div>
      </div>
    </div>
  `;
}

function renderPublicParticipantsSection(tournament) {
  const players = tournament.players || [];
  const playersMap = new Map(players.map((p) => [p.id, p]));

  const mastersBracket = tournament.playoffs.mastersBracket;
  const challengeBracket = tournament.playoffs.challengeBracket;

  const mastersMedals = extractWinnersFromBracket(mastersBracket);
  const challengeMedals = extractWinnersFromBracket(challengeBracket);

  const { medals: medalMap, resultLabels } = collectTournamentResults(
    tournament
  );

  const groups = tournament.groups || [];
  const groupByPlayer = new Map();
  groups.forEach((g, idx) => {
    for (const pid of g.playerIds || []) {
      groupByPlayer.set(pid, idx + 1);
    }
  });

  const mastersPlayers = new Set(
    (tournament.playoffs.mastersBracket?.players || []).map((p) => p)
  );
  const challengePlayers = new Set(
    (tournament.playoffs.challengeBracket?.players || []).map((p) => p)
  );

  function buildStatus(pid) {
    if (mastersPlayers.has(pid)) {
      return {
        label: "–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤",
        className: "lp-badge lp-badge-masters",
      };
    }
    if (challengePlayers.has(pid)) {
      return {
        label: "–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞",
        className: "lp-badge lp-badge-challenge",
      };
    }
    const groupIndex = groupByPlayer.get(pid);
    if (groupIndex) {
      return {
        label: `–ì—Ä—É–ø–ø–∞ ${groupIndex}`,
        className: "lp-badge lp-badge-group",
      };
    }
    return {
      label: "–û–∂–∏–¥–∞–µ—Ç –∂–µ—Ä–µ–±—å—ë–≤–∫–∏",
      className: "lp-badge lp-badge-gray",
    };
  }

  let html = `
    <section id="section-participants" class="lp-card">
      <div class="lp-card-header">
        <h3 class="lp-card-title">–£—á–∞—Å—Ç–Ω–∏–∫–∏</h3>
        <span class="lp-card-subtitle">–í—Å–µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: ${players.length}</span>
      </div>
  `;

  let podiumsHtml = "";
  if (mastersBracket) {
    podiumsHtml += renderPodium("–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤", mastersMedals, playersMap);
  }
  if (challengeBracket) {
    podiumsHtml += renderPodium("–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞", challengeMedals, playersMap);
  }

  if (podiumsHtml) {
    html += `
      <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:12px;">
        ${podiumsHtml}
      </div>
    `;
  }

  html += `
      <div class="lp-table-scroll" style="margin-top:12px;">
        <table class="lp-table lp-table--sticky-name lp-table-participants">
          <thead>
            <tr>
              <th>–ò–º—è</th>
              <th>–§–∞–º–∏–ª–∏—è</th>
              <th>LDAP</th>
              <th>–°—Ç–∞—Ç—É—Å</th>
              <th>–†–µ–∑—É–ª—å—Ç–∞—Ç</th>
            </tr>
          </thead>
          <tbody>
  `;

  players.forEach((p) => {
    const status = buildStatus(p.id);
    const medalEmoji = medalMap.get(p.id) || "";
    const resultText = resultLabels.get(p.id) || "";
    const resultCell =
      (medalEmoji ? `<span class="lp-medal">${medalEmoji}</span> ` : "") +
      escapeHtml(resultText);

    html += `
      <tr>
        <td>${escapeHtml(p.firstName)}</td>
        <td>${escapeHtml(p.lastName)}</td>
        <td>${escapeHtml(p.ldap)}</td>
        <td class="lp-status-cell"><span class="${status.className}">${status.label}</span></td>
        <td>${resultCell}</td>
      </tr>
    `;
  });

  html += `
          </tbody>
        </table>
      </div>
    </section>
  `;
  return html;
}


// ---------------------
// –ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π (—Ñ—É–Ω–∫—Ü–∏–∏ –æ—Å—Ç–∞–≤–∏–ª–∏, –Ω–æ –ø–æ–∫–∞ –Ω–µ —Ä–µ–Ω–¥–µ—Ä–∏–º)
// ---------------------

function renderHistorySection(tournament, isAdmin) {
  const history = tournament.history || [];
  const playersMap = new Map(tournament.players.map((p) => [p.id, p]));
  const filter = isAdmin ? adminHistoryFilter : publicHistoryFilter;

  const filtered = history.filter((h) => {
    if (filter === "all") return true;
    if (filter === "groups") return h.stage === "groups";
    if (filter === "masters") return h.stage === "masters";
    if (filter === "challenge") return h.stage === "challenge";
    return true;
  });

  let html = `
    <section class="lp-card">
      <div class="lp-card-header">
        <h3 class="lp-card-title">–ò—Å—Ç–æ—Ä–∏—è –º–∞—Ç—á–µ–π</h3>
      </div>
      <div class="lp-chip-row" data-history-filter-root="${
        isAdmin ? "admin" : "public"
      }">
        ${renderHistoryFilterChip("all", "–í—Å–µ", filter)}
        ${renderHistoryFilterChip("groups", "–ì—Ä—É–ø–ø–æ–≤–æ–π —ç—Ç–∞–ø", filter)}
        ${renderHistoryFilterChip("masters", "–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤", filter)}
        ${renderHistoryFilterChip("challenge", "–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞", filter)}
      </div>
  `;

  if (filtered.length === 0) {
    html += `<p class="lp-text-muted lp-text-xs" style="margin-top:8px;">
      –ú–∞—Ç—á–∏ –µ—â—ë –Ω–µ —Å—ã–≥—Ä–∞–Ω—ã –∏–ª–∏ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.
    </p>`;
  } else {
    html += `<div class="lp-matches-list" style="margin-top:8px; max-width:700px; margin-left:auto; margin-right:auto;">`;
    const sorted = [...filtered].sort((a, b) => b.createdAt - a.createdAt);
    for (const item of sorted) {
      const p1Name =
        item.player1Name ||
        (() => {
          const p = playersMap.get(item.player1Id);
          return p ? `${p.firstName} ${p.lastName}` : "‚Äî";
        })();
      const p2Name =
        item.player2Name ||
        (() => {
          const p = playersMap.get(item.player2Id);
          return p ? `${p.firstName} ${p.lastName}` : "‚Äî";
        })();
      const score = `${item.score1}:${item.score2}`;
      const winnerId = item.winnerId;

      const w1Class = winnerId === item.player1Id ? "lp-match-winner" : "";
      const w2Class = winnerId === item.player2Id ? "lp-match-winner" : "";

      const stageLabel =
        item.stage === "groups"
          ? "–ì—Ä—É–ø–ø–æ–≤–æ–π —ç—Ç–∞–ø"
          : item.stage === "masters"
          ? "–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤"
          : item.stage === "challenge"
          ? "–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞"
          : "";

      html += `
        <div class="lp-match-row">
          <div class="lp-match-player lp-match-player--left ${w1Class}">
            ${escapeHtml(p1Name)}
          </div>
          <div class="lp-match-score">
            ${score}
          </div>
          <div class="lp-match-player lp-match-player--right ${w2Class}">
            ${escapeHtml(p2Name)}
          </div>
        </div>
        <div class="lp-text-muted lp-text-xs" style="margin:0 10px 6px;">
          ${formatDateTime(item.createdAt)} ¬∑ ${stageLabel}
        </div>
      `;
    }
    html += `</div>`;
  }

  html += `</section>`;
  return html;
}

function renderHistoryFilterChip(value, label, current) {
  const active = value === current ? "lp-chip lp-chip--active" : "lp-chip";
  return `<button type="button" class="${active}" data-history-filter="${value}">${label}</button>`;
}

function bindHistoryFilterHandlers(isAdmin) {
  const root = document.querySelector(
    `[data-history-filter-root="${isAdmin ? "admin" : "public"}"]`
  );
  if (!root) return;

  root.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-history-filter]");
    if (!btn) return;

    const value = btn.dataset.historyFilter;
    if (isAdmin) {
      adminHistoryFilter = value;
    } else {
      publicHistoryFilter = value;
    }

    if (isAdminPage === isAdmin) {
      render();
    }
  });
}

// ---------------------
// –ü—É–±–ª–∏—á–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
// ---------------------

function handlePublicRegisterPlayer(firstName, lastName, ldap) {
  const t = getActiveTournament(currentState);
  if (!t) {
    alert("–ê–∫—Ç–∏–≤–Ω—ã–π —Ç—É—Ä–Ω–∏—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä—É.");
    return;
  }
  if (!t.registrationOpen) {
    alert("–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É–∂–µ –∑–∞–∫—Ä—ã—Ç–∞.");
    return;
  }

  updateState((state) => {
    const tour = getActiveTournament(state);
    if (!tour) return;
    const newPlayer = {
      id: generateId("p"),
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      ldap: ldap.trim(),
    };
    tour.players.push(newPlayer);
  });
}

// ---------------------
// –†–µ–Ω–¥–µ—Ä –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏
// ---------------------

function renderAdminPage() {
  const root = document.getElementById("admin-root");
  if (!root) return;

  const state = currentState;
  const tournaments = state.tournaments || [];

  const activePublicTournament = getActiveTournament(state);

  let editingTournament = getEditingTournament(state);
  if (!editingTournament && tournaments.length > 0) {
    editingTournament = activePublicTournament || tournaments[0];
    adminEditingTournamentId = editingTournament.id;
  }

  let html = `
    <section class="lp-card">
      <div class="lp-card-header">
        <h2 class="lp-card-title">–¢—É—Ä–Ω–∏—Ä—ã</h2>
      </div>
      <div class="lp-row" style="margin-top:8px; align-items:flex-end;">
        <div style="flex:1 1 160px; min-width:160px;">
          <label class="lp-text-xs">–¢—É—Ä–Ω–∏—Ä –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</label>
          <select id="admin-tournament-select" class="lp-select">
  `;

  if (tournaments.length === 0) {
    html += `<option value="">(—Ç—É—Ä–Ω–∏—Ä–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç)</option>`;
  } else {
    tournaments.forEach((t) => {
      const selected =
        editingTournament && t.id === editingTournament.id ? "selected" : "";
      html += `<option value="${escapeHtml(t.id)}" ${selected}>${escapeHtml(
        t.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
      )}</option>`;
    });
  }

  html += `
          </select>
        </div>
        <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="set-active-tournament">
          –°–¥–µ–ª–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–º
        </button>
        <div class="lp-spacer"></div>
        <div style="flex:1 1 200px; min-width:180px;">
          <label class="lp-text-xs">–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç—É—Ä–Ω–∏—Ä–∞</label>
          <input type="text" id="admin-new-tournament-name" class="lp-input" placeholder="–ö—É–±–æ–∫ 2025" />
        </div>
        <button type="button" class="lp-btn lp-btn-primary lp-btn-sm" data-action="create-tournament">
          –°–æ–∑–¥–∞—Ç—å —Ç—É—Ä–Ω–∏—Ä
        </button>
      </div>
  `;

  if (activePublicTournament) {
    html += `
      <div class="lp-separator"></div>
      <p class="lp-text-muted lp-text-xs">
        <strong>–°–µ–π—á–∞—Å –Ω–∞ –ø—É–±–ª–∏—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Çc—è:</strong>
        ${escapeHtml(activePublicTournament.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")}
      </p>
    `;
  } else {
    html += `
      <div class="lp-separator"></div>
      <p class="lp-text-muted lp-text-xs">
        –ù–∞ –ø—É–±–ª–∏—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ –ø–æ–∫–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω –∞–∫—Ç–∏–≤–Ω—ã–π —Ç—É—Ä–Ω–∏—Ä.
      </p>
    `;
  }

  html += `</section>`;

  if (!editingTournament) {
    html += `
      <div class="lp-card">
        <p class="lp-text-muted">
          –°–æ–∑–¥–∞–π—Ç–µ —Ç—É—Ä–Ω–∏—Ä, —á—Ç–æ–±—ã —É–ø—Ä–∞–≤–ª—è—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏, –≥—Ä—É–ø–ø–∞–º–∏ –∏ –ø–ª–µ–π-–æ—Ñ—Ñ.
        </p>
      </div>
    `;
    root.innerHTML = html;
    bindAdminRootHandlers();
    return;
  }

  const tournament = ensureTournamentShape(editingTournament);

  html += `
    <section class="lp-card">
      <div class="lp-card-header">
        <h3 class="lp-card-title">–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</h3>
      </div>
      <div class="lp-row" style="margin-top:8px; align-items:center;">
        <span class="lp-text-muted lp-text-xs">–°–æ—Å—Ç–æ—è–Ω–∏–µ: ${
          tournament.registrationOpen
            ? "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∞"
            : "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–∫—Ä—ã—Ç–∞"
        }</span>
        <div class="lp-spacer"></div>
        <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="toggle-registration">
          ${
            tournament.registrationOpen
              ? "–ó–∞–∫—Ä—ã—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é"
              : "–û—Ç–∫—Ä—ã—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é"
          }
        </button>
        <button type="button" class="lp-btn lp-btn-danger lp-btn-sm" data-action="reset-groups-playoffs">
          –°–±—Ä–æ—Å–∏—Ç—å –≥—Ä—É–ø–ø—ã –∏ –ø–ª–µ–π-–æ—Ñ—Ñ (–ø–æ–ª–Ω—ã–π)
        </button>
      </div>
    </section>
  `;

  html += renderAdminPlayersSection(tournament);
  html += renderAdminGroupsSection(tournament);
  html += renderAdminPlayoffsSection(tournament);

  root.innerHTML = html;
  bindAdminRootHandlers();
}

function renderAdminPlayersSection(tournament) {
  const players = tournament.players || [];
  let html = `
    <section class="lp-card">
      <div class="lp-card-header">
        <h3 class="lp-card-title">–£—á–∞—Å—Ç–Ω–∏–∫–∏ —Ç—É—Ä–Ω–∏—Ä–∞</h3>
        <span class="lp-card-subtitle">–í—Å–µ–≥–æ: ${players.length}</span>
      </div>
      <div class="lp-row" style="margin-top:8px; align-items:flex-end;">
        <div style="flex:1 1 120px; min-width:120px;">
          <label class="lp-text-xs">–ò–º—è</label>
          <input type="text" id="admin-add-firstName" class="lp-input" placeholder="–ò–≤–∞–Ω" />
        </div>
        <div style="flex:1 1 120px; min-width:120px;">
          <label class="lp-text-xs">–§–∞–º–∏–ª–∏—è</label>
          <input type="text" id="admin-add-lastName" class="lp-input" placeholder="–ò–≤–∞–Ω–æ–≤" />
        </div>
        <div style="flex:1 1 120px; min-width:120px;">
          <label class="lp-text-xs">LDAP</label>
          <input type="text" id="admin-add-ldap" class="lp-input" placeholder="–∫–æ—Ä–ø. –ª–æ–≥–∏–Ω" />
        </div>
        <button type="button" class="lp-btn lp-btn-primary lp-btn-sm" data-action="add-player">
          –î–æ–±–∞–≤–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞
        </button>
      </div>
      <div class="lp-table-scroll" style="margin-top:10px;">
        <table class="lp-table lp-table--sticky-name">
          <thead>
            <tr>
              <th>–ò–º—è</th>
              <th>–§–∞–º–∏–ª–∏—è</th>
              <th>LDAP</th>
              <th style="width:150px;">–î–µ–π—Å—Ç–≤–∏—è</th>
            </tr>
          </thead>
          <tbody>
  `;

  players.forEach((p) => {
    html += `
      <tr>
        <td>
          <input type="text" class="lp-input-inline" data-player-id="${escapeHtml(
            p.id
          )}" data-player-field="firstName" value="${escapeHtml(
      p.firstName
    )}" />
        </td>
        <td>
          <input type="text" class="lp-input-inline" data-player-id="${escapeHtml(
            p.id
          )}" data-player-field="lastName" value="${escapeHtml(
      p.lastName
    )}" />
        </td>
        <td>
          <input type="text" class="lp-input-inline" data-player-id="${escapeHtml(
            p.id
          )}" data-player-field="ldap" value="${escapeHtml(p.ldap)}" />
        </td>
        <td>
          <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="save-player" data-player-id="${escapeHtml(
            p.id
          )}">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
          <button type="button" class="lp-btn lp-btn-danger lp-btn-sm" data-action="delete-player" data-player-id="${escapeHtml(
            p.id
          )}">–£–¥–∞–ª–∏—Ç—å</button>
        </td>
      </tr>
    `;
  });

  html += `
          </tbody>
        </table>
      </div>
    </section>
  `;
  return html;
}

function renderAdminGroupsSection(tournament) {
  const groups = tournament.groups || [];
  const players = tournament.players || [];
  const playersMap = new Map(players.map((p) => [p.id, p]));

  const playerIdsInGroups = new Set();
  groups.forEach((g) => {
    (g.playerIds || []).forEach((id) => playerIdsInGroups.add(id));
  });
  const playersWithoutGroup = players.filter((p) => !playerIdsInGroups.has(p.id));

  let html = `
    <section class="lp-card">
      <div class="lp-card-header">
        <h3 class="lp-card-title">–ì—Ä—É–ø–ø–æ–≤–æ–π —ç—Ç–∞–ø</h3>
        <span class="lp-card-subtitle">–†–∞—É–Ω–¥ ¬´–∫–∞–∂–¥—ã–π —Å –∫–∞–∂–¥—ã–º¬ª</span>
      </div>
      <div class="lp-row" style="margin-top:8px; flex-wrap:wrap; gap:8px;">
        <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="generate-groups">
          –†–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ –≥—Ä—É–ø–ø–∞–º (–ø–æ ~4 —á–µ–ª.)
        </button>
        <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="generate-playoffs">
          –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π-–æ—Ñ—Ñ
        </button>
        <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="fill-random-group-results">
          –ó–∞–ø–æ–ª–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–ª—É—á–∞–π–Ω–æ
        </button>
        <button type="button" class="lp-btn lp-btn-danger lp-btn-sm" data-action="reset-group-results">
          –°–±—Ä–æ—Å–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≥—Ä—É–ø–ø
        </button>
      </div>
  `;

  if (groups.length > 0) {
    html += `
      <div class="lp-row" style="margin-top:10px; flex-wrap:wrap; gap:8px;">
        <div style="flex:1 1 200px; min-width:180px;">
          <label class="lp-text-xs">–ò–≥—Ä–æ–∫</label>
          <select id="admin-group-player-select" class="lp-select">
            <option value="">(–≤—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä–æ–∫–∞)</option>
    `;
    players.forEach((p) => {
      html += `<option value="${escapeHtml(
        p.id
      )}">${escapeHtml(p.firstName)} ${escapeHtml(p.lastName)}</option>`;
    });
    html += `
          </select>
        </div>
        <div style="flex:1 1 160px; min-width:160px;">
          <label class="lp-text-xs">–ì—Ä—É–ø–ø–∞</label>
          <select id="admin-group-target-select" class="lp-select">
            <option value="">–ë–µ–∑ –≥—Ä—É–ø–ø—ã</option>
    `;
    groups.forEach((g, idx) => {
      html += `<option value="${escapeHtml(
        g.id
      )}">–ì—Ä—É–ø–ø–∞ ${idx + 1}</option>`;
    });
    html += `
          </select>
        </div>
        <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="move-player-to-group">
          –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤ –≥—Ä—É–ø–ø—É
        </button>
      </div>
      <p class="lp-text-muted lp-text-xs" style="margin-top:4px;">
        –ò–∑–º–µ–Ω—è—Ç—å —Å–æ—Å—Ç–∞–≤ –≥—Ä—É–ø–ø –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ–∫–∞ –≤ –≥—Ä—É–ø–ø–∞—Ö –Ω–µ—Ç —Å—ã–≥—Ä–∞–Ω–Ω—ã—Ö –º–∞—Ç—á–µ–π.
      </p>
    `;

    if (playersWithoutGroup.length > 0) {
      html += `<p class="lp-text-muted lp-text-xs" style="margin-top:6px;">–ò–≥—Ä–æ–∫–∏ –±–µ–∑ –≥—Ä—É–ø–ø—ã: `;
      playersWithoutGroup.forEach((p) => {
        const name = `${escapeHtml(p.firstName)} ${escapeHtml(p.lastName)}`;
        html += `<span class="lp-badge lp-badge-gray" style="margin-right:4px; margin-bottom:2px;">${name}</span>`;
      });
      html += `</p>`;
    } else {
      html += `<p class="lp-text-muted lp-text-xs" style="margin-top:6px;">
        –í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –ø–æ –≥—Ä—É–ø–ø–∞–º.
      </p>`;
    }
  } else {
    html += `
      <p class="lp-text-muted lp-text-xs" style="margin-top:8px;">
        –ì—Ä—É–ø–ø—ã –µ—â—ë –Ω–µ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω—ã. –ù–∞–∂–º–∏—Ç–µ ¬´–†–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ –≥—Ä—É–ø–ø–∞–º¬ª, –∫–æ–≥–¥–∞ —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤.
      </p>
    `;
  }

  if (groups.length > 0) {
    groups.forEach((g, idx) => {
      const standings = g.standings || [];
      const allMatches = g.matches || [];
      const mainMatches = allMatches.filter((m) => !m.isTiebreak);
      const tiebreakMatches = allMatches.filter((m) => m.isTiebreak);
      const hasTiebreaks = tiebreakMatches.length > 0;
      const tInfo = g.tiebreakInfo || null;

      html += `
        <div class="lp-group-card">
          <div class="lp-group-header-line">
            <span class="lp-group-name">–ì—Ä—É–ø–ø–∞ ${idx + 1}</span>
            <span class="lp-group-note">
              –ü–æ–±–µ–¥–∞ 2:0 ‚Äî 3 –æ—á–∫–∞; 2:1 ‚Äî 2 –æ—á–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—é –∏ 1 –æ—á–∫–æ –ø—Ä–æ–∏–≥—Ä–∞–≤—à–µ–º—É. 
              –í —Å–∫–æ–±–∫–∞—Ö ‚Äî —Ä–∞–∑–Ω–∏—Ü–∞ —Å–µ—Ç–æ–≤.
            </span>
          </div>
          <div class="lp-table-scroll">
            <table class="lp-table lp-table--sticky-name">
              <thead>
                <tr>
                  <th>–ò–≥—Ä–æ–∫</th>
                  <th>–°–µ—Ç—ã</th>
                  <th>(+/‚àí)</th>
                  <th>–ü–æ–±–µ–¥—ã</th>
                  <th>–ü–æ—Ä–∞–∂–µ–Ω–∏—è</th>
                  <th>–û—á–∫–∏</th>
                </tr>
              </thead>
              <tbody>
      `;
      standings.forEach((row, pos) => {
        const p = playersMap.get(row.playerId);
        const name = p
          ? `${escapeHtml(p.firstName)} ${escapeHtml(p.lastName)}`
          : "‚Äî";
        const diff = row.setsFor - row.setsAgainst;
        const diffText = diff > 0 ? `+${diff}` : `${diff}`;
        const highlight = pos <= 1 ? "lp-table-row-highlight" : "";
        html += `
          <tr class="${highlight}">
            <td>${name}</td>
            <td>${row.setsFor}:${row.setsAgainst}</td>
            <td>${diffText}</td>
            <td>${row.wins}</td>
            <td>${row.losses}</td>
            <td>${row.points}</td>
          </tr>
        `;
      });
      html += `
              </tbody>
            </table>
          </div>

          <div class="lp-card-section-title" style="margin-top:10px;">–ú–∞—Ç—á–∏ –≥—Ä—É–ø–ø—ã</div>
          <div class="lp-table-scroll">
            <table class="lp-table">
              <thead>
                <tr>
                  <th>–ò–≥—Ä–æ–∫ 1</th>
                  <th>–ò–≥—Ä–æ–∫ 2</th>
                  <th>–°—á—ë—Ç</th>
                  <th>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</th>
                </tr>
              </thead>
              <tbody>
      `;
      mainMatches.forEach((m) => {
        const p1 = playersMap.get(m.player1Id);
        const p2 = playersMap.get(m.player2Id);
        const name1 = p1
          ? `${escapeHtml(p1.firstName)} ${escapeHtml(p1.lastName)}`
          : "‚Äî";
        const name2 = p2
          ? `${escapeHtml(p2.firstName)} ${escapeHtml(p2.lastName)}`
          : "‚Äî";
        const score1 = m.score1 != null ? m.score1 : "";
        const score2 = m.score2 != null ? m.score2 : "";
        html += `
          <tr>
            <td>${name1}</td>
            <td>${name2}</td>
            <td>
              <input type="number" min="0" max="2" class="lp-input-inline lp-input-score" id="gm-${m.id}-s1" value="${score1}" />
              :
              <input type="number" min="0" max="2" class="lp-input-inline lp-input-score" id="gm-${m.id}-s2" value="${score2}" />
            </td>
            <td>
              <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="save-group-match" data-group-id="${escapeHtml(
                g.id
              )}" data-match-id="${escapeHtml(m.id)}">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </td>
          </tr>
        `;
      });
      html += `
              </tbody>
            </table>
          </div>
      `;

      if (hasTiebreaks) {
        html += `
          <div class="lp-card-section-title" style="margin-top:10px;">–ü–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤</div>
        `;
        if (tInfo && tInfo.message) {
          html += `
            <p class="lp-text-muted lp-text-xs" style="margin-top:4px;">
              ${escapeHtml(tInfo.message)}
            </p>
          `;
        }
        html += `
          <div class="lp-table-scroll" style="margin-top:4px;">
            <table class="lp-table">
              <thead>
                <tr>
                  <th>–ò–≥—Ä–æ–∫ 1</th>
                  <th>–ò–≥—Ä–æ–∫ 2</th>
                  <th>–°—á—ë—Ç</th>
                  <th>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</th>
                </tr>
              </thead>
              <tbody>
        `;
        tiebreakMatches.forEach((m) => {
          const p1 = playersMap.get(m.player1Id);
          const p2 = playersMap.get(m.player2Id);
          const name1 = p1
            ? `${escapeHtml(p1.firstName)} ${escapeHtml(p1.lastName)}`
            : "‚Äî";
          const name2 = p2
            ? `${escapeHtml(p2.firstName)} ${escapeHtml(p2.lastName)}`
            : "‚Äî";
          const score1 = m.score1 != null ? m.score1 : "";
          const score2 = m.score2 != null ? m.score2 : "";
          html += `
            <tr>
              <td>${name1}</td>
              <td>${name2}</td>
              <td>
                <input type="number" min="0" max="2" class="lp-input-inline lp-input-score" id="gm-${m.id}-s1" value="${score1}" />
                :
                <input type="number" min="0" max="2" class="lp-input-inline lp-input-score" id="gm-${m.id}-s2" value="${score2}" />
              </td>
              <td>
                <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="save-group-match" data-group-id="${escapeHtml(
                  g.id
                )}" data-match-id="${escapeHtml(m.id)}">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
              </td>
            </tr>
          `;
        });
        html += `
              </tbody>
            </table>
          </div>
        `;
      }

      html += `
        </div>
      `;
    });
  }

  html += `</section>`;
  return html;
}

function renderAdminPlayoffsSection(tournament) {
  const playersMap = new Map(tournament.players.map((p) => [p.id, p]));
  const mastersBracket = tournament.playoffs.mastersBracket;
  const challengeBracket = tournament.playoffs.challengeBracket;

  let html = `
    <section class="lp-card">
      <div class="lp-card-header">
        <h3 class="lp-card-title">–ü–ª–µ–π-–æ—Ñ—Ñ</h3>
      </div>
      <p class="lp-text-muted lp-text-xs" style="margin-top:4px;">
        –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —ç—Ç–∞–ø–∞ –Ω–∞–∂–º–∏—Ç–µ ¬´–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π-–æ—Ñ—Ñ¬ª. –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –≤–≤–æ–¥–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–∞—Ç—á–µ–π, –ø–æ–±–µ–¥–∏—Ç–µ–ª–∏ –±—É–¥—É—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–æ–¥–≤–∏–≥–∞—Ç—å—Å—è –ø–æ —Å–µ—Ç–∫–µ.
      </p>
      <div class="lp-row" style="margin-top:8px; flex-wrap:wrap; gap:8px;">
        <button type="button" class="lp-btn lp-btn-danger lp-btn-sm" data-action="reset-playoff-results">
          –°–±—Ä–æ—Å–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–ª–µ–π-–æ—Ñ—Ñ
        </button>
      </div>
      <div class="lp-brackets-wrapper" style="margin-top:10px;">
  `;

  if (!mastersBracket && !challengeBracket) {
    html += `<p class="lp-text-muted lp-text-xs" style="margin-top:8px;">
      –ü–ª–µ–π-–æ—Ñ—Ñ –µ—â—ë –Ω–µ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω.
    </p>`;
    html += `</section>`;
    return html;
  }

  if (mastersBracket) {
    html += `
      <div>
        <h4 class="lp-card-section-title">–ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤</h4>
        <div class="lp-bracket">
          ${renderAdminBracket(mastersBracket, playersMap, "masters")}
        </div>
      </div>
    `;
  }

  if (challengeBracket) {
    html += `
      <div>
        <h4 class="lp-card-section-title">–ö—É–±–æ–∫ –≤—ã–∑–æ–≤–∞</h4>
        <div class="lp-bracket">
          ${renderAdminBracket(challengeBracket, playersMap, "challenge")}
        </div>
      </div>
    `;
  }

  html += `</div></section>`;
  return html;
}

function renderAdminBracket(bracket, playersMap, bracketType) {
  if (!bracket || !bracket.rounds || bracket.rounds.length === 0) {
    return `<p class="lp-text-muted lp-text-xs">–°–µ—Ç–∫–∞ –µ—â—ë –Ω–µ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∞.</p>`;
  }

  const bracketPlayers = Array.isArray(bracket.players) ? bracket.players : [];

  let html = `<div class="lp-bracket-inner">`;
  for (const round of bracket.rounds) {
    const isFinal = round.name === "–§–∏–Ω–∞–ª";
    const isThird = round.name === "–ú–∞—Ç—á –∑–∞ 3-–µ –º–µ—Å—Ç–æ";
    const roundClass = isFinal
      ? "lp-bracket-round lp-bracket-round--final"
      : isThird
      ? "lp-bracket-round lp-bracket-round--third"
      : "lp-bracket-round";

    html += `<div class="${roundClass}">
      <div class="lp-bracket-round-title">${escapeHtml(round.name)}</div>
    `;

    for (const match of round.matches) {
      if (shouldHideByeMatch(match, round)) continue;

      const p1 = playersMap.get(match.player1Id);
      const p2 = playersMap.get(match.player2Id);
      const name1 = p1
        ? `${escapeHtml(p1.firstName)} ${escapeHtml(p1.lastName)}`
        : "‚Äî";
      const name2 = p2
        ? `${escapeHtml(p2.firstName)} ${escapeHtml(p2.lastName)}`
        : "‚Äî";

      const s1 = match.score1 != null ? match.score1 : "";
      const s2 = match.score2 != null ? match.score2 : "";

      const canEditPlayers =
        bracketPlayers.length > 0 &&
        match.score1 == null &&
        match.score2 == null;

      let player1Control = `<span class="lp-bracket-player-name">${name1}</span>`;
      let player2Control = `<span class="lp-bracket-player-name">${name2}</span>`;

      if (canEditPlayers) {
        let optionsHtml1 = `<option value="">‚Äî</option>`;
        bracketPlayers.forEach((pid) => {
          const pl = playersMap.get(pid);
          if (!pl) return;
          const label = `${escapeHtml(pl.firstName)} ${escapeHtml(
            pl.lastName
          )}`;
          const optSelected = pid === match.player1Id ? "selected" : "";
          optionsHtml1 += `<option value="${escapeHtml(
            pid
          )}" ${optSelected}>${label}</option>`;
        });

        let optionsHtml2 = `<option value="">‚Äî</option>`;
        bracketPlayers.forEach((pid) => {
          const pl = playersMap.get(pid);
          if (!pl) return;
          const label = `${escapeHtml(pl.firstName)} ${escapeHtml(
            pl.lastName
          )}`;
          const optSelected = pid === match.player2Id ? "selected" : "";
          optionsHtml2 += `<option value="${escapeHtml(
            pid
          )}" ${optSelected}>${label}</option>`;
        });

        player1Control = `
          <select
            class="lp-select"
            style="padding:2px 6px; font-size:12px;"
            data-action="set-playoff-player"
            data-bracket="${bracketType}"
            data-match-id="${escapeHtml(match.id)}"
            data-slot="p1"
          >
            ${optionsHtml1}
          </select>
        `;

        player2Control = `
          <select
            class="lp-select"
            style="padding:2px 6px; font-size:12px;"
            data-action="set-playoff-player"
            data-bracket="${bracketType}"
            data-match-id="${escapeHtml(match.id)}"
            data-slot="p2"
          >
            ${optionsHtml2}
          </select>
        `;
      }

      html += `
        <div class="lp-bracket-match">
          <div class="lp-bracket-match-label">–ú–∞—Ç—á</div>
          <div class="lp-bracket-player-row">
            ${player1Control}
          </div>
          <div class="lp-bracket-player-row" style="margin-bottom:4px;">
            ${player2Control}
          </div>
          <div class="lp-row" style="align-items:center;">
            <div>
              <input type="number" min="0" max="2" class="lp-input-inline lp-input-score" id="pm-${match.id}-s1" value="${s1}" />
              :
              <input type="number" min="0" max="2" class="lp-input-inline lp-input-score" id="pm-${match.id}-s2" value="${s2}" />
            </div>
            <div class="lp-spacer"></div>
            <button type="button" class="lp-btn lp-btn-outline lp-btn-sm" data-action="save-playoff-match" data-bracket="${bracketType}" data-round-id="${escapeHtml(
        round.id
      )}" data-match-id="${escapeHtml(match.id)}">
              –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
            </button>
          </div>
        </div>
      `;
    }

    html += `</div>`;
  }
  html += `</div>`;
  return html;
}
// ---------------------
// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏
// ---------------------

function bindAdminRootHandlers() {
  const root = document.getElementById("admin-root");
  if (!root) return;

  root.onclick = (e) => {
    const btn = e.target.closest("[data-action]");
    if (!btn) return;
    const action = btn.dataset.action;

    switch (action) {
      case "create-tournament":
        handleCreateTournament();
        break;
      case "set-active-tournament":
        handleSetActiveTournament();
        break;
      case "toggle-registration":
        handleToggleRegistration();
        break;
      case "reset-groups-playoffs":
        handleResetGroupsPlayoffs();
        break;
      case "reset-group-results":
        handleResetGroupResults();
        break;
      case "fill-random-group-results":
        handleFillRandomGroupResults();
        break;
      case "reset-playoff-results":
        handleResetPlayoffResults();
        break;
      case "add-player":
        handleAddPlayer();
        break;
      case "save-player":
        handleSavePlayer(btn.dataset.playerId);
        break;
      case "delete-player":
        handleDeletePlayer(btn.dataset.playerId);
        break;
      case "generate-groups":
        handleGenerateGroups();
        break;
      case "move-player-to-group":
        handleMovePlayerToGroup();
        break;
      case "save-group-match":
        handleSaveGroupMatch(btn.dataset.groupId, btn.dataset.matchId);
        break;
      case "generate-playoffs":
        handleGeneratePlayoffs();
        break;
      case "save-playoff-match":
        handleSavePlayoffMatch(
          btn.dataset.bracket,
          btn.dataset.roundId,
          btn.dataset.matchId
        );
        break;
      default:
        break;
    }
  };

  root.addEventListener("change", (e) => {
    const select = e.target.closest("select[data-action]");
    if (!select) return;
    const action = select.dataset.action;
    if (action === "set-playoff-player") {
      handleSetPlayoffPlayer(
        select.dataset.bracket,
        select.dataset.matchId,
        select.dataset.slot,
        select.value || ""
      );
    }
  });

  const select = document.getElementById("admin-tournament-select");
  if (select) {
    select.addEventListener("change", () => {
      adminEditingTournamentId = select.value || null;
      render();
    });
  }
}

function handleCreateTournament() {
  const input = document.getElementById("admin-new-tournament-name");
  const name = input ? input.value.trim() : "";
  if (!name) {
    alert("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—É—Ä–Ω–∏—Ä–∞.");
    return;
  }

  const id = generateId("t");
  const now = Date.now();

  updateState((state) => {
    const tournament = {
      id,
      name,
      createdAt: now,
      status: "registration",
      registrationOpen: true,
      players: [],
      groups: [],
      history: [],
      playoffs: {
        mastersBracket: null,
        challengeBracket: null,
      },
    };
    state.tournaments.push(tournament);
  });

  adminEditingTournamentId = id;
  if (input) input.value = "";
}

function handleSetActiveTournament() {
  const select = document.getElementById("admin-tournament-select");
  if (!select) return;
  const value = select.value || null;
  updateState((state) => {
    state.activeTournamentId = value;
  });
}

function handleToggleRegistration() {
  if (!adminEditingTournamentId) return;
  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    tour.registrationOpen = !tour.registrationOpen;
    if (tour.registrationOpen) {
      tour.status = "registration";
    }
  });
}

function handleResetGroupsPlayoffs() {
  if (
    !confirm(
      "–ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–±—Ä–æ—Å–∏—Ç—å –≥—Ä—É–ø–ø—ã, –ø–ª–µ–π-–æ—Ñ—Ñ –∏ –∏—Å—Ç–æ—Ä–∏—é –º–∞—Ç—á–µ–π –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ç—É—Ä–Ω–∏—Ä–∞?"
    )
  ) {
    return;
  }
  if (!adminEditingTournamentId) return;
  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    tour.groups = [];
    tour.playoffs = {
      mastersBracket: null,
      challengeBracket: null,
    };
    tour.history = [];
    tour.status = "registration";
  });
}

function handleResetGroupResults() {
  if (!adminEditingTournamentId) return;
  if (
    !confirm(
      "–°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —ç—Ç–∞–ø–∞? –°–æ—Å—Ç–∞–≤ –≥—Ä—É–ø–ø –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –ø—Ä–µ–∂–Ω–∏–º."
    )
  ) {
    return;
  }
  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour || !tour.groups) return;
    tour.groups.forEach((g) => {
      (g.matches || []).forEach((m) => {
        m.score1 = null;
        m.score2 = null;
      });
      g.standings = recomputeGroupStandings(g, tour);
      g.tiebreakInfo = null;
    });
    tour.history = (tour.history || []).filter((h) => h.stage !== "groups");
  });
}

function handleFillRandomGroupResults() {
  if (!adminEditingTournamentId) return;
  if (
    !confirm(
      "–°–ª—É—á–∞–π–Ω–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—Å–µ—Ö –º–∞—Ç—á–µ–π –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —ç—Ç–∞–ø–∞, –≥–¥–µ –µ—â—ë –Ω–µ—Ç —Å—á—ë—Ç–∞? –£–∂–µ –≤–≤–µ–¥—ë–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏–∑–º–µ–Ω–µ–Ω—ã –Ω–µ –±—É–¥—É—Ç."
    )
  ) {
    return;
  }

  // —Å—é–¥–∞ –±—É–¥–µ–º —Å–∫–ª–∞–¥—ã–≤–∞—Ç—å –Ω–æ–º–µ—Ä–∞ –≥—Ä—É–ø–ø, –≥–¥–µ –ø–æ–Ω–∞–¥–æ–±–∏–ª–∏—Å—å –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏
  let groupsWithTie = [];

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour || !tour.groups) return;

    const variants = [
      [2, 0],
      [2, 1],
      [0, 2],
      [1, 2],
    ];

    tour.groups.forEach((g, idx) => {
      // –∑–∞–ø–æ–ª–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –ø—É—Å—Ç—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      (g.matches || []).forEach((m) => {
        if (m.score1 != null && m.score2 != null) return;
        const [s1, s2] = variants[Math.floor(Math.random() * variants.length)];
        m.score1 = s1;
        m.score2 = s2;
      });

      // –ø–µ—Ä–µ—Å—á—ë—Ç —Ç–∞–±–ª–∏—Ü—ã
      g.standings = recomputeGroupStandings(g, tour);

      // ‚úÖ —Å—Ä–∞–∑—É –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–æ–∫
      const tb = ensureMastersTiebreakMatches(g, tour);
      if (tb.needTiebreak) {
        groupsWithTie.push(idx + 1); // –∑–∞–ø–æ–º–Ω–∏–º –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã (—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏–π, —Å 1)
      }
    });

    // –∏—Å—Ç–æ—Ä–∏—é –º–∞—Ç—á–µ–π –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
  });

  if (groupsWithTie.length) {
    alert(
      "–í –≥—Ä—É–ø–ø–∞—Ö " +
        groupsWithTie.join(", ") +
        " –ø–æ–ª–Ω–æ–µ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤.\n" +
        "–°–æ–∑–¥–∞–Ω—ã –º–∞—Ç—á–∏-–ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç –æ—Å–Ω–æ–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π. " +
        "–°–Ω–∞—á–∞–ª–∞ —Å—ã–≥—Ä–∞–π—Ç–µ –∏—Ö, –∑–∞—Ç–µ–º —Å—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ –ø–ª–µ–π-–æ—Ñ—Ñ."
    );
  }
}

function handleResetPlayoffResults() {
  if (!adminEditingTournamentId) return;
  if (
    !confirm(
      "–°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–ª–µ–π-–æ—Ñ—Ñ –∏ –ø–µ—Ä–µ—Å–æ–±—Ä–∞—Ç—å —Å–µ—Ç–∫—É –ø–æ —Ç–µ–∫—É—â–∏–º –≥—Ä—É–ø–ø–∞–º?"
    )
  ) {
    return;
  }
  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;

    tour.history = (tour.history || []).filter(
      (h) => h.stage !== "masters" && h.stage !== "challenge"
    );

    if (!tour.groups || tour.groups.length === 0) {
      tour.playoffs = {
        mastersBracket: null,
        challengeBracket: null,
      };
      return;
    }

    const standingsByGroup = new Map();
    tour.groups.forEach((g) => {
      g.standings = recomputeGroupStandings(g, tour);
      standingsByGroup.set(g.id, g.standings);
    });

    const mastersPlayers = createMastersPlayersFromGroups(
      tour.groups,
      standingsByGroup
    );
    const challengePlayers = createChallengePlayersFromGroups(
      tour.groups,
      standingsByGroup
    );

    tour.playoffs = {
      mastersBracket:
        mastersPlayers.length >= 2
          ? createBracketFromPlayers(mastersPlayers, "masters")
          : null,
      challengeBracket:
        challengePlayers.length >= 2
          ? createBracketFromPlayers(challengePlayers, "challenge")
          : null,
    };

    if (tour.playoffs.mastersBracket || tour.playoffs.challengeBracket) {
      tour.status = "playoffs";
    }
  });
}

function handleAddPlayer() {
  if (!adminEditingTournamentId) return;
  const firstNameEl = document.getElementById("admin-add-firstName");
  const lastNameEl = document.getElementById("admin-add-lastName");
  const ldapEl = document.getElementById("admin-add-ldap");
  const firstName = (firstNameEl?.value || "").trim();
  const lastName = (lastNameEl?.value || "").trim();
  const ldap = (ldapEl?.value || "").trim();
  if (!firstName || !lastName || !ldap) {
    alert("–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ò–º—è, –§–∞–º–∏–ª–∏—é –∏ LDAP.");
    return;
  }

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    const newPlayer = {
      id: generateId("p"),
      firstName,
      lastName,
      ldap,
    };
    tour.players.push(newPlayer);
  });

  if (firstNameEl) firstNameEl.value = "";
  if (lastNameEl) lastNameEl.value = "";
  if (ldapEl) ldapEl.value = "";
}

function handleSavePlayer(playerId) {
  if (!playerId || !adminEditingTournamentId) return;
  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    const p = tour.players.find((pl) => pl.id === playerId);
    if (!p) return;
    const inputs = document.querySelectorAll(
      `[data-player-id="${playerId}"][data-player-field]`
    );
    inputs.forEach((input) => {
      const field = input.dataset.playerField;
      const value = input.value.trim();
      if (field && value != null) {
        p[field] = value;
      }
    });
  });
}

function handleDeletePlayer(playerId) {
  if (!playerId || !adminEditingTournamentId) return;
  if (!confirm("–£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∏ –≤—Å–µ –µ–≥–æ –º–∞—Ç—á–∏?")) return;
  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    tour.players = tour.players.filter((p) => p.id !== playerId);
    tour.groups.forEach((g) => {
      g.playerIds = (g.playerIds || []).filter((id) => id !== playerId);
      g.matches = (g.matches || []).filter(
        (m) => m.player1Id !== playerId && m.player2Id !== playerId
      );
      g.standings = (g.standings || []).filter(
        (s) => s.playerId !== playerId
      );
    });
    tour.history = (tour.history || []).filter(
      (h) => h.player1Id !== playerId && h.player2Id !== playerId
    );
  });
}

function handleGenerateGroups() {
  if (!adminEditingTournamentId) return;
  const t = getTournamentById(currentState, adminEditingTournamentId);
  if (!t) return;

  if (hasGroupResults(t)) {
    alert(
      "–ù–µ–ª—å–∑—è –∑–∞–Ω–æ–≤–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è—Ç—å –ø–æ –≥—Ä—É–ø–ø–∞–º: —É–∂–µ –µ—Å—Ç—å —Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏. –°–Ω–∞—á–∞–ª–∞ —Å–±—Ä–æ—Å—å—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —ç—Ç–∞–ø–∞."
    );
    return;
  }

  if (t.players.length < 4 && !confirm("–ú–µ–Ω–µ–µ 4 –∏–≥—Ä–æ–∫–æ–≤. –í—Å—ë —Ä–∞–≤–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å?")) {
    return;
  }

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;

    const groupsRaw = createGroupsFromPlayers(tour.players);
    const groups = groupsRaw.map((gRaw, idx) => {
      const id = generateId("g");
      const matches = createRoundRobinMatchesForGroup(
        tour.id,
        id,
        gRaw.playerIds
      );
      return {
        id,
        name: `–ì—Ä—É–ø–ø–∞ ${idx + 1}`,
        stage: "groups",
        playerIds: gRaw.playerIds,
        matches,
        standings: [],
        tiebreakInfo: null,
      };
    });

    groups.forEach((g) => {
      g.standings = recomputeGroupStandings(g, tour);
    });

    tour.groups = groups;
    tour.status = "groups";
    tour.history = (tour.history || []).filter(
      (h) =>
        h.stage !== "groups" && h.stage !== "masters" && h.stage !== "challenge"
    );
    tour.playoffs = {
      mastersBracket: null,
      challengeBracket: null,
    };
  });
}

function handleMovePlayerToGroup() {
  if (!adminEditingTournamentId) return;
  const t = getTournamentById(currentState, adminEditingTournamentId);
  if (!t) return;

  if (hasGroupResults(t)) {
    alert(
      "–ù–µ–ª—å–∑—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ—Å—Ç–∞–≤ –≥—Ä—É–ø–ø: —É–∂–µ –µ—Å—Ç—å —Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏. –°–Ω–∞—á–∞–ª–∞ —Å–±—Ä–æ—Å—å—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —ç—Ç–∞–ø–∞."
    );
    return;
  }

  const playerSelect = document.getElementById("admin-group-player-select");
  const groupSelect = document.getElementById("admin-group-target-select");
  if (!playerSelect || !groupSelect) return;

  const playerId = playerSelect.value;
  const targetGroupId = groupSelect.value;

  if (!playerId) {
    alert("–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä–æ–∫–∞.");
    return;
  }

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    const groups = tour.groups || [];

    groups.forEach((g) => {
      g.playerIds = (g.playerIds || []).filter((id) => id !== playerId);
      g.matches = (g.matches || []).filter(
        (m) => m.player1Id !== playerId && m.player2Id !== playerId
      );
      g.tiebreakInfo = null;
    });

    if (targetGroupId) {
      const group = groups.find((g) => g.id === targetGroupId);
      if (!group) return;
      group.playerIds = group.playerIds || [];
      if (!group.playerIds.includes(playerId)) {
        group.playerIds.push(playerId);
      }
      group.matches = createRoundRobinMatchesForGroup(
        tour.id,
        group.id,
        group.playerIds
      );
    }

    groups.forEach((g) => {
      g.standings = recomputeGroupStandings(g, tour);
    });

    tour.history = (tour.history || []).filter((h) => h.stage !== "groups");
  });
}

function handleSaveGroupMatch(groupId, matchId) {
  if (!adminEditingTournamentId) return;

  const s1Input = document.getElementById(`gm-${matchId}-s1`);
  const s2Input = document.getElementById(`gm-${matchId}-s2`);
  if (!s1Input || !s2Input) return;
  const s1 = Number(s1Input.value);
  const s2 = Number(s2Input.value);

  if (!isValidScore(s1, s2)) {
    alert("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å—á—ë—Ç. –î–æ–ø—É—Å—Ç–∏–º—ã —Ç–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã 2‚Äì0, 2‚Äì1, 0‚Äì2, 1‚Äì2.");
    return;
  }

  // —Ñ–ª–∞–≥–∏, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–ø–æ–ª–Ω–∏–º –≤–Ω—É—Ç—Ä–∏ updateState
  let tiebreakCreated = false;
  let tiebreakGroupNumber = null;

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    const group = tour.groups.find((g) => g.id === groupId);
    if (!group) return;
    const match = group.matches.find((m) => m.id === matchId);
    if (!match) return;

    match.score1 = s1;
    match.score2 = s2;

    // –ø–µ—Ä–µ—Å—á—ë—Ç —Ç–∞–±–ª–∏—Ü—ã
    group.standings = recomputeGroupStandings(group, tour);

    // ‚úÖ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–æ–∫ –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –º–∞—Ç—á–∞
    const tbResult = ensureMastersTiebreakMatches(group, tour);

    // –Ω–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ –∏–º–µ–Ω–Ω–æ —Å–µ–π—á–∞—Å –±—ã–ª–∏ –°–û–ó–î–ê–ù–´ –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏
    if (tbResult && tbResult.needTiebreak && tbResult.reason === "created") {
      tiebreakCreated = true;
      const idx = tour.groups.findIndex((g) => g.id === groupId);
      if (idx !== -1) {
        tiebreakGroupNumber = idx + 1;
      }
    }

    const res = getWinnerLoser(s1, s2, match.player1Id, match.player2Id);
    if (!res) return;
    const p1 = tour.players.find((p) => p.id === match.player1Id);
    const p2 = tour.players.find((p) => p.id === match.player2Id);
    const description = `${p1 ? p1.firstName + " " + p1.lastName : "‚Äî"} ${s1}:${s2} ${
      p2 ? p2.firstName + " " + p2.lastName : "‚Äî"
    }`;

    const existing = tour.history.find((h) => h.matchId === match.id);
    const payload = {
      id: existing ? existing.id : generateId("h"),
      matchId: match.id,
      tournamentId: tour.id,
      createdAt: Date.now(),
      description,
      groupId: group.id,
      stage: "groups",
      winnerId: res.winnerId,
      player1Id: match.player1Id,
      player2Id: match.player2Id,
      player1Name: p1 ? `${p1.firstName} ${p1.lastName}` : null,
      player2Name: p2 ? `${p2.firstName} ${p2.lastName}` : null,
      score1: s1,
      score2: s2,
    };

    if (existing) {
      Object.assign(existing, payload);
    } else {
      tour.history.push(payload);
    }
  });

  // —É–∂–µ –ø–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  if (tiebreakCreated) {
    const groupText = tiebreakGroupNumber
      ? `–í –≥—Ä—É–ø–ø–µ ${tiebreakGroupNumber}`
      : "–í –æ–¥–Ω–æ–π –∏–∑ –≥—Ä—É–ø–ø";
    alert(
      groupText +
        " –ø–æ–ª–Ω–æ–µ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤.\n" +
        "–°–æ–∑–¥–∞–Ω—ã –º–∞—Ç—á–∏-–ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç –æ—Å–Ω–æ–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π. " +
        "–°–Ω–∞—á–∞–ª–∞ —Å—ã–≥—Ä–∞–π—Ç–µ –∏—Ö, –∑–∞—Ç–µ–º —Å—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ –ø–ª–µ–π-–æ—Ñ—Ñ."
    );
  }
}

function handleGeneratePlayoffs() {
  if (!adminEditingTournamentId) return;
  const t = getTournamentById(currentState, adminEditingTournamentId);
  if (!t) return;

  if (!t.groups || t.groups.length === 0) {
    alert("–°–Ω–∞—á–∞–ª–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –∏–≥—Ä–æ–∫–æ–≤ –ø–æ –≥—Ä—É–ø–ø–∞–º.");
    return;
  }

  if (hasPlayoffResults(t)) {
    alert(
      "–ù–µ–ª—å–∑—è –∑–∞–Ω–æ–≤–æ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π-–æ—Ñ—Ñ: —É–∂–µ –µ—Å—Ç—å —Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏. –°–Ω–∞—á–∞–ª–∞ —Å–±—Ä–æ—Å—å—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–ª–µ–π-–æ—Ñ—Ñ."
    );
    return;
  }

  let needTiebreak = false;
  const groupsWithTie = [];

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;

    const standingsByGroup = new Map();

    tour.groups.forEach((g, idx) => {
      g.standings = recomputeGroupStandings(g, tour);
      standingsByGroup.set(g.id, g.standings);

      const tb = ensureMastersTiebreakMatches(g, tour);
      if (tb.needTiebreak) {
        needTiebreak = true;
        groupsWithTie.push(idx + 1);
      }
    });

    if (needTiebreak) {
      tour.playoffs = {
        mastersBracket: null,
        challengeBracket: null,
      };
      tour.status = "groups";
      return;
    }

    const mastersPlayers = createMastersPlayersFromGroups(
      tour.groups,
      standingsByGroup
    );
    const challengePlayers = createChallengePlayersFromGroups(
      tour.groups,
      standingsByGroup
    );

    tour.playoffs = {
      mastersBracket:
        mastersPlayers.length >= 2
          ? createBracketFromPlayers(mastersPlayers, "masters")
          : null,
      challengeBracket:
        challengePlayers.length >= 2
          ? createBracketFromPlayers(challengePlayers, "challenge")
          : null,
    };
    tour.status = "playoffs";
  });

  if (needTiebreak) {
    alert(
      "–í –≥—Ä—É–ø–ø–∞—Ö " +
        groupsWithTie.join(", ") +
        " –ø–æ–ª–Ω–æ–µ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –∑–∞ –≤—ã—Ö–æ–¥ –≤ –ö—É–±–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤.\n" +
        "–°–æ–∑–¥–∞–Ω—ã –º–∞—Ç—á–∏-–ø–µ—Ä–µ–∏–≥—Ä–æ–≤–∫–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç –æ—Å–Ω–æ–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π. " +
        "–°–Ω–∞—á–∞–ª–∞ —Å—ã–≥—Ä–∞–π—Ç–µ –∏—Ö, –∑–∞—Ç–µ–º —Å–Ω–æ–≤–∞ –Ω–∞–∂–º–∏—Ç–µ ¬´–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π-–æ—Ñ—Ñ¬ª."
    );
  }
}

function handleSavePlayoffMatch(bracketType, roundId, matchId) {
  if (!adminEditingTournamentId) return;
  const t = getTournamentById(currentState, adminEditingTournamentId);
  if (!t) return;
  const bracket =
    bracketType === "masters"
      ? t.playoffs.mastersBracket
      : t.playoffs.challengeBracket;
  if (!bracket) return;

  const s1Input = document.getElementById(`pm-${matchId}-s1`);
  const s2Input = document.getElementById(`pm-${matchId}-s2`);
  if (!s1Input || !s2Input) return;
  const s1 = Number(s1Input.value);
  const s2 = Number(s2Input.value);

  if (!isValidScore(s1, s2)) {
    alert("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å—á—ë—Ç. –î–æ–ø—É—Å—Ç–∏–º—ã —Ç–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç—ã 2‚Äì0, 2‚Äì1, 0‚Äì2, 1‚Äì2.");
    return;
  }

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    const b =
      bracketType === "masters"
        ? tour.playoffs.mastersBracket
        : tour.playoffs.challengeBracket;
    if (!b) return;

    let foundMatch = null;
    for (const round of b.rounds) {
      if (round.id !== roundId) continue;
      const m = round.matches.find((x) => x.id === matchId);
      if (m) {
        foundMatch = m;
        break;
      }
    }
    if (!foundMatch) return;

    foundMatch.score1 = s1;
    foundMatch.score2 = s2;

    const res = getWinnerLoser(
      s1,
      s2,
      foundMatch.player1Id,
      foundMatch.player2Id
    );
    if (!res) return;

    applyPlayoffResultToBracket(b, foundMatch, res.winnerId, res.loserId);

    const p1 = tour.players.find((p) => p.id === foundMatch.player1Id);
    const p2 = tour.players.find((p) => p.id === foundMatch.player2Id);
    const description = `${p1 ? p1.firstName + " " + p1.lastName : "‚Äî"} ${s1}:${s2} ${
      p2 ? p2.firstName + " " + p2.lastName : "‚Äî"
    }`;

    const existing = tour.history.find((h) => h.matchId === foundMatch.id);
    const payload = {
      id: existing ? existing.id : generateId("h"),
      matchId: foundMatch.id,
      tournamentId: tour.id,
      createdAt: Date.now(),
      description,
      groupId: null,
      stage: bracketType === "masters" ? "masters" : "challenge",
      winnerId: res.winnerId,
      player1Id: foundMatch.player1Id,
      player2Id: foundMatch.player2Id,
      player1Name: p1 ? `${p1.firstName} ${p1.lastName}` : null,
      player2Name: p2 ? `${p2.firstName} ${p2.lastName}` : null,
      score1: s1,
      score2: s2,
    };

    if (existing) {
      Object.assign(existing, payload);
    } else {
      tour.history.push(payload);
    }
  });
}

function handleSetPlayoffPlayer(bracketType, matchId, slot, playerId) {
  if (!adminEditingTournamentId) return;
  const t = getTournamentById(currentState, adminEditingTournamentId);
  if (!t) return;

  if (hasPlayoffResults(t)) {
    alert(
      "–ù–µ–ª—å–∑—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–µ—Ç–∫—É: —É–∂–µ –µ—Å—Ç—å —Å—ã–≥—Ä–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏ –ø–ª–µ–π-–æ—Ñ—Ñ. –°–Ω–∞—á–∞–ª–∞ —Å–±—Ä–æ—Å—å—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–ª–µ–π-–æ—Ñ—Ñ."
    );
    return;
  }

  updateState((state) => {
    const tour = getTournamentById(state, adminEditingTournamentId);
    if (!tour) return;
    const b =
      bracketType === "masters"
        ? tour.playoffs.mastersBracket
        : tour.playoffs.challengeBracket;
    if (!b || !b.rounds) return;

    let foundMatch = null;
    for (const round of b.rounds) {
      const m = (round.matches || []).find((x) => x.id === matchId);
      if (m) {
        foundMatch = m;
        break;
      }
    }
    if (!foundMatch) return;

    if (slot === "p1") {
      foundMatch.player1Id = playerId || null;
    } else if (slot === "p2") {
      foundMatch.player2Id = playerId || null;
    }
  });
}

// ---------------------
// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
// ---------------------

async function init() {
  if (isInitialized) return;
  isInitialized = true;

  try {
    const initial = await loadStateFromCloud();
    currentState = normalizeState(initial);
    render();

    subscribeToState((remoteState) => {
      currentState = normalizeState(remoteState);
      render();
    });
  } catch (err) {
    console.error("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:", err);
    const containerId = isAdminPage ? "admin-root" : "public-root";
    const root = document.getElementById(containerId);
    if (root) {
      root.innerHTML = `
        <div class="lp-card">
          <h2 class="lp-card-title">–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</h2>
          <p class="lp-text-muted">–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é Firebase –≤ —Ñ–∞–π–ª–µ <code>firebase.js</code>.</p>
        </div>
      `;
    }
  }
}

function render() {
  if (isAdminPage) {
    renderAdminPage();
  } else {
    renderPublicPage();
  }
}

document.addEventListener("DOMContentLoaded", init);